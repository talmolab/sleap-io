{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"sleap-io documentation","text":""},{"location":"model/","title":"Data model","text":""},{"location":"model/#sleap_io.model.labels","title":"<code>sleap_io.model.labels</code>","text":"<p>Data structure for the labels, a top-level container for pose data.</p> <p><code>Label</code>s contain <code>LabeledFrame</code>s, which in turn contain <code>Instance</code>s, which contain <code>Point</code>s.</p> <p>This structure also maintains metadata that is common across all child objects such as <code>Track</code>s, <code>Video</code>s, <code>Skeleton</code>s and others.</p> <p>It is intended to be the entrypoint for deserialization and main container that should be used for serialization. It is designed to support both labeled data (used for training models) and predictions (inference results).</p>"},{"location":"model/#sleap_io.model.labels.Labels","title":"<code>Labels</code>","text":"<p>Pose data for a set of videos that have user labels and/or predictions.</p> <p>Attributes:</p> Name Type Description <code>labeled_frames</code> <code>list[LabeledFrame]</code> <p>A list of <code>LabeledFrame</code>s that are associated with this dataset.</p> <code>videos</code> <code>list[Video]</code> <p>A list of <code>Video</code>s that are associated with this dataset. Videos do not need to have corresponding <code>LabeledFrame</code>s if they do not have any labels or predictions yet.</p> <code>skeletons</code> <code>list[Skeleton]</code> <p>A list of <code>Skeleton</code>s that are associated with this dataset. This should generally only contain a single skeleton.</p> <code>tracks</code> <code>list[Track]</code> <p>A list of <code>Track</code>s that are associated with this dataset.</p> <code>provenance</code> <code>dict[str, Any]</code> <p>Dictionary of arbitrary metadata providing additional information about where the dataset came from.</p> Notes <p><code>Video</code>s in contain <code>LabeledFrame</code>s, and <code>Skeleton</code>s and <code>Track</code>s in contained <code>Instance</code>s are added to the respective lists automatically.</p> Source code in <code>sleap_io/model/labels.py</code> <pre><code>@define\nclass Labels:\n    \"\"\"Pose data for a set of videos that have user labels and/or predictions.\n\n    Attributes:\n        labeled_frames: A list of `LabeledFrame`s that are associated with this dataset.\n        videos: A list of `Video`s that are associated with this dataset. Videos do not\n            need to have corresponding `LabeledFrame`s if they do not have any\n            labels or predictions yet.\n        skeletons: A list of `Skeleton`s that are associated with this dataset. This\n            should generally only contain a single skeleton.\n        tracks: A list of `Track`s that are associated with this dataset.\n        provenance: Dictionary of arbitrary metadata providing additional information\n            about where the dataset came from.\n\n    Notes:\n        `Video`s in contain `LabeledFrame`s, and `Skeleton`s and `Track`s in contained\n        `Instance`s are added to the respective lists automatically.\n    \"\"\"\n\n    labeled_frames: list[LabeledFrame] = field(factory=list)\n    videos: list[Video] = field(factory=list)\n    skeletons: list[Skeleton] = field(factory=list)\n    tracks: list[Track] = field(factory=list)\n    provenance: dict[str, Any] = field(factory=dict)\n\n    def __attrs_post_init__(self):\n        \"\"\"Append videos, skeletons, and tracks seen in `labeled_frames` to `Labels`.\"\"\"\n        for lf in self.labeled_frames:\n            if lf.video not in self.videos:\n                self.videos.append(lf.video)\n\n            for inst in lf:\n                if inst.skeleton not in self.skeletons:\n                    self.skeletons.append(inst.skeleton)\n\n                if inst.track is not None and inst.track not in self.tracks:\n                    self.tracks.append(inst.track)\n\n    def __getitem__(self, key: int) -&gt; list[LabeledFrame] | LabeledFrame:\n        \"\"\"Return one or more labeled frames based on indexing criteria.\"\"\"\n        if type(key) == int:\n            return self.labeled_frames[key]\n        elif type(key) == slice:\n            return [self.labeled_frames[i] for i in range(*key.indices(len(self)))]\n        elif type(key) == list:\n            return [self.labeled_frames[i] for i in key]\n        elif isinstance(key, np.ndarray):\n            return [self.labeled_frames[i] for i in key.tolist()]\n        elif type(key) == tuple and len(key) == 2:\n            video, frame_idx = key\n            res = self.find(video, frame_idx)\n            if len(res) == 1:\n                return res[0]\n            elif len(res) == 0:\n                raise IndexError(\n                    f\"No labeled frames found for video {video} and \"\n                    f\"frame index {frame_idx}.\"\n                )\n        elif type(key) == Video:\n            res = self.find(key)\n            if len(res) == 0:\n                raise IndexError(f\"No labeled frames found for video {key}.\")\n            return res\n        else:\n            raise IndexError(f\"Invalid indexing argument for labels: {key}\")\n\n    def __iter__(self):\n        \"\"\"Iterate over `labeled_frames` list when calling iter method on `Labels`.\"\"\"\n        return iter(self.labeled_frames)\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return number of labeled frames.\"\"\"\n        return len(self.labeled_frames)\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a readable representation of the labels.\"\"\"\n        return (\n            \"Labels(\"\n            f\"labeled_frames={len(self.labeled_frames)}, \"\n            f\"videos={len(self.videos)}, \"\n            f\"skeletons={len(self.skeletons)}, \"\n            f\"tracks={len(self.tracks)}\"\n            \")\"\n        )\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a readable representation of the labels.\"\"\"\n        return self.__repr__()\n\n    def numpy(\n        self,\n        video: Optional[Union[Video, int]] = None,\n        all_frames: bool = True,\n        untracked: bool = False,\n        return_confidence: bool = False,\n    ) -&gt; np.ndarray:\n        \"\"\"Construct a numpy array from instance points.\n\n        Args:\n            video: Video or video index to convert to numpy arrays. If `None` (the\n                default), uses the first video.\n            untracked: If `False` (the default), include only instances that have a\n                track assignment. If `True`, includes all instances in each frame in\n                arbitrary order.\n            return_confidence: If `False` (the default), only return points of nodes. If\n                `True`, return the points and scores of nodes.\n\n        Returns:\n            An array of tracks of shape `(n_frames, n_tracks, n_nodes, 2)` if\n            `return_confidence` is `False`. Otherwise returned shape is\n            `(n_frames, n_tracks, n_nodes, 3)` if `return_confidence` is `True`.\n\n            Missing data will be replaced with `np.nan`.\n\n            If this is a single instance project, a track does not need to be assigned.\n\n            Only predicted instances (NOT user instances) will be returned.\n\n        Notes:\n            This method assumes that instances have tracks assigned and is intended to\n            function primarily for single-video prediction results.\n        \"\"\"\n        # Get labeled frames for specified video.\n        if video is None:\n            video = 0\n        if type(video) == int:\n            video = self.videos[video]\n        lfs = [lf for lf in self.labeled_frames if lf.video == video]\n\n        # Figure out frame index range.\n        first_frame, last_frame = 0, 0\n        for lf in lfs:\n            first_frame = min(first_frame, lf.frame_idx)\n            last_frame = max(last_frame, lf.frame_idx)\n\n        # Figure out the number of tracks based on number of instances in each frame.\n        # First, let's check the max number of predicted instances (regardless of\n        # whether they're tracked.\n        n_preds = 0\n        for lf in lfs:\n            n_pred_instances = len(lf.predicted_instances)\n            n_preds = max(n_preds, n_pred_instances)\n\n        # Case 1: We don't care about order because there's only 1 instance per frame,\n        # or we're considering untracked instances.\n        untracked = untracked or n_preds == 1\n        if untracked:\n            n_tracks = n_preds\n        else:\n            # Case 2: We're considering only tracked instances.\n            n_tracks = len(self.tracks)\n\n        n_frames = int(last_frame - first_frame + 1)\n        skeleton = self.skeletons[-1]  # Assume project only uses last skeleton\n        n_nodes = len(skeleton.nodes)\n\n        if return_confidence:\n            tracks = np.full((n_frames, n_tracks, n_nodes, 3), np.nan, dtype=\"float32\")\n        else:\n            tracks = np.full((n_frames, n_tracks, n_nodes, 2), np.nan, dtype=\"float32\")\n        for lf in lfs:\n            i = int(lf.frame_idx - first_frame)\n            if untracked:\n                for j, inst in enumerate(lf.predicted_instances):\n                    tracks[i, j] = inst.numpy(scores=return_confidence)\n            else:\n                tracked_instances = [\n                    inst\n                    for inst in lf.instances\n                    if type(inst) == PredictedInstance and inst.track is not None\n                ]\n                for inst in tracked_instances:\n                    j = self.tracks.index(inst.track)  # type: ignore[arg-type]\n                    tracks[i, j] = inst.numpy(scores=return_confidence)\n\n        return tracks\n\n    @property\n    def video(self) -&gt; Video:\n        \"\"\"Return the video if there is only a single video in the labels.\"\"\"\n        if len(self.videos) == 0:\n            raise ValueError(\"There are no videos in the labels.\")\n        elif len(self.videos) == 1:\n            return self.videos[0]\n        else:\n            raise ValueError(\n                \"Labels.video can only be used when there is only a single video saved \"\n                \"in the labels. Use Labels.videos instead.\"\n            )\n\n    @property\n    def skeleton(self) -&gt; Skeleton:\n        \"\"\"Return the skeleton if there is only a single skeleton in the labels.\"\"\"\n        if len(self.skeletons) == 0:\n            raise ValueError(\"There are no skeletons in the labels.\")\n        elif len(self.skeletons) == 1:\n            return self.skeletons[0]\n        else:\n            raise ValueError(\n                \"Labels.skeleton can only be used when there is only a single skeleton \"\n                \"saved in the labels. Use Labels.skeletons instead.\"\n            )\n\n    def find(\n        self,\n        video: Video,\n        frame_idx: int | list[int] | None = None,\n        return_new: bool = False,\n    ) -&gt; list[LabeledFrame]:\n        \"\"\"Search for labeled frames given video and/or frame index.\n\n        Args:\n            video: A `Video` that is associated with the project.\n            frame_idx: The frame index (or indices) which we want to find in the video.\n                If a range is specified, we'll return all frames with indices in that\n                range. If not specific, then we'll return all labeled frames for video.\n            return_new: Whether to return singleton of new and empty `LabeledFrame` if\n                none are found in project.\n\n        Returns:\n            List of `LabeledFrame` objects that match the criteria.\n\n                The list will be empty if no matches found, unless return_new is True,\n                in which case it contains new (empty) `LabeledFrame` objects with `video`\n                and `frame_index` set.\n        \"\"\"\n        results = []\n\n        if frame_idx is None:\n            for lf in self.labeled_frames:\n                if lf.video == video:\n                    results.append(lf)\n            return results\n\n        if np.isscalar(frame_idx):\n            frame_idx = np.array(frame_idx).reshape(-1)\n\n        for frame_ind in frame_idx:\n            result = None\n            for lf in self.labeled_frames:\n                if lf.video == video and lf.frame_idx == frame_ind:\n                    result = lf\n                    results.append(result)\n                    break\n            if result is None and return_new:\n                results.append(LabeledFrame(video=video, frame_idx=frame_ind))\n\n        return results\n\n    def save(self, filename: str, format: Optional[str] = None, **kwargs):\n        \"\"\"Save labels to file in specified format.\n\n        Args:\n            filename: Path to save labels to.\n            format: The format to save the labels in. If `None`, the format will be\n                inferred from the file extension. Available formats are \"slp\", \"nwb\",\n                \"labelstudio\", and \"jabs\".\n        \"\"\"\n        from sleap_io import save_file\n\n        save_file(self, filename, format=format, **kwargs)\n\n    def clean(\n        self,\n        frames: bool = True,\n        empty_instances: bool = False,\n        skeletons: bool = True,\n        tracks: bool = True,\n        videos: bool = False,\n    ):\n        \"\"\"Remove empty frames, unused skeletons, tracks and videos.\n\n        Args:\n            frames: If `True` (the default), remove empty frames.\n            empty_instances: If `True` (NOT default), remove instances that have no\n                visible points.\n            skeletons: If `True` (the default), remove unused skeletons.\n            tracks: If `True` (the default), remove unused tracks.\n            videos: If `True` (NOT default), remove videos that have no labeled frames.\n        \"\"\"\n        used_skeletons = []\n        used_tracks = []\n        used_videos = []\n        kept_frames = []\n        for lf in self.labeled_frames:\n\n            if empty_instances:\n                lf.remove_empty_instances()\n\n            if frames and len(lf) == 0:\n                continue\n\n            if videos and lf.video not in used_videos:\n                used_videos.append(lf.video)\n\n            if skeletons or tracks:\n                for inst in lf:\n                    if skeletons and inst.skeleton not in used_skeletons:\n                        used_skeletons.append(inst.skeleton)\n                    if (\n                        tracks\n                        and inst.track is not None\n                        and inst.track not in used_tracks\n                    ):\n                        used_tracks.append(inst.track)\n\n            if frames:\n                kept_frames.append(lf)\n\n        if videos:\n            self.videos = [video for video in self.videos if video in used_videos]\n\n        if skeletons:\n            self.skeletons = [\n                skeleton for skeleton in self.skeletons if skeleton in used_skeletons\n            ]\n\n        if tracks:\n            self.tracks = [track for track in self.tracks if track in used_tracks]\n\n        if frames:\n            self.labeled_frames = kept_frames\n\n    def remove_predictions(self, clean: bool = True):\n        \"\"\"Remove all predicted instances from the labels.\n\n        Args:\n            clean: If `True` (the default), also remove any empty frames and unused\n                tracks and skeletons. It does NOT remove videos that have no labeled\n                frames or instances with no visible points.\n\n        See also: `Labels.clean`\n        \"\"\"\n        for lf in self.labeled_frames:\n            lf.remove_predictions()\n\n        if clean:\n            self.clean(\n                frames=True,\n                empty_instances=False,\n                skeletons=True,\n                tracks=True,\n                videos=False,\n            )\n</code></pre>"},{"location":"model/#sleap_io.model.labels.Labels.skeleton","title":"<code>skeleton: Skeleton</code>  <code>property</code>","text":"<p>Return the skeleton if there is only a single skeleton in the labels.</p>"},{"location":"model/#sleap_io.model.labels.Labels.video","title":"<code>video: Video</code>  <code>property</code>","text":"<p>Return the video if there is only a single video in the labels.</p>"},{"location":"model/#sleap_io.model.labels.Labels.__attrs_post_init__","title":"<code>__attrs_post_init__()</code>","text":"<p>Append videos, skeletons, and tracks seen in <code>labeled_frames</code> to <code>Labels</code>.</p> Source code in <code>sleap_io/model/labels.py</code> <pre><code>def __attrs_post_init__(self):\n    \"\"\"Append videos, skeletons, and tracks seen in `labeled_frames` to `Labels`.\"\"\"\n    for lf in self.labeled_frames:\n        if lf.video not in self.videos:\n            self.videos.append(lf.video)\n\n        for inst in lf:\n            if inst.skeleton not in self.skeletons:\n                self.skeletons.append(inst.skeleton)\n\n            if inst.track is not None and inst.track not in self.tracks:\n                self.tracks.append(inst.track)\n</code></pre>"},{"location":"model/#sleap_io.model.labels.Labels.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Return one or more labeled frames based on indexing criteria.</p> Source code in <code>sleap_io/model/labels.py</code> <pre><code>def __getitem__(self, key: int) -&gt; list[LabeledFrame] | LabeledFrame:\n    \"\"\"Return one or more labeled frames based on indexing criteria.\"\"\"\n    if type(key) == int:\n        return self.labeled_frames[key]\n    elif type(key) == slice:\n        return [self.labeled_frames[i] for i in range(*key.indices(len(self)))]\n    elif type(key) == list:\n        return [self.labeled_frames[i] for i in key]\n    elif isinstance(key, np.ndarray):\n        return [self.labeled_frames[i] for i in key.tolist()]\n    elif type(key) == tuple and len(key) == 2:\n        video, frame_idx = key\n        res = self.find(video, frame_idx)\n        if len(res) == 1:\n            return res[0]\n        elif len(res) == 0:\n            raise IndexError(\n                f\"No labeled frames found for video {video} and \"\n                f\"frame index {frame_idx}.\"\n            )\n    elif type(key) == Video:\n        res = self.find(key)\n        if len(res) == 0:\n            raise IndexError(f\"No labeled frames found for video {key}.\")\n        return res\n    else:\n        raise IndexError(f\"Invalid indexing argument for labels: {key}\")\n</code></pre>"},{"location":"model/#sleap_io.model.labels.Labels.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate over <code>labeled_frames</code> list when calling iter method on <code>Labels</code>.</p> Source code in <code>sleap_io/model/labels.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over `labeled_frames` list when calling iter method on `Labels`.\"\"\"\n    return iter(self.labeled_frames)\n</code></pre>"},{"location":"model/#sleap_io.model.labels.Labels.__len__","title":"<code>__len__()</code>","text":"<p>Return number of labeled frames.</p> Source code in <code>sleap_io/model/labels.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return number of labeled frames.\"\"\"\n    return len(self.labeled_frames)\n</code></pre>"},{"location":"model/#sleap_io.model.labels.Labels.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a readable representation of the labels.</p> Source code in <code>sleap_io/model/labels.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a readable representation of the labels.\"\"\"\n    return (\n        \"Labels(\"\n        f\"labeled_frames={len(self.labeled_frames)}, \"\n        f\"videos={len(self.videos)}, \"\n        f\"skeletons={len(self.skeletons)}, \"\n        f\"tracks={len(self.tracks)}\"\n        \")\"\n    )\n</code></pre>"},{"location":"model/#sleap_io.model.labels.Labels.__str__","title":"<code>__str__()</code>","text":"<p>Return a readable representation of the labels.</p> Source code in <code>sleap_io/model/labels.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a readable representation of the labels.\"\"\"\n    return self.__repr__()\n</code></pre>"},{"location":"model/#sleap_io.model.labels.Labels.clean","title":"<code>clean(frames=True, empty_instances=False, skeletons=True, tracks=True, videos=False)</code>","text":"<p>Remove empty frames, unused skeletons, tracks and videos.</p> <p>Parameters:</p> Name Type Description Default <code>frames</code> <code>bool</code> <p>If <code>True</code> (the default), remove empty frames.</p> <code>True</code> <code>empty_instances</code> <code>bool</code> <p>If <code>True</code> (NOT default), remove instances that have no visible points.</p> <code>False</code> <code>skeletons</code> <code>bool</code> <p>If <code>True</code> (the default), remove unused skeletons.</p> <code>True</code> <code>tracks</code> <code>bool</code> <p>If <code>True</code> (the default), remove unused tracks.</p> <code>True</code> <code>videos</code> <code>bool</code> <p>If <code>True</code> (NOT default), remove videos that have no labeled frames.</p> <code>False</code> Source code in <code>sleap_io/model/labels.py</code> <pre><code>def clean(\n    self,\n    frames: bool = True,\n    empty_instances: bool = False,\n    skeletons: bool = True,\n    tracks: bool = True,\n    videos: bool = False,\n):\n    \"\"\"Remove empty frames, unused skeletons, tracks and videos.\n\n    Args:\n        frames: If `True` (the default), remove empty frames.\n        empty_instances: If `True` (NOT default), remove instances that have no\n            visible points.\n        skeletons: If `True` (the default), remove unused skeletons.\n        tracks: If `True` (the default), remove unused tracks.\n        videos: If `True` (NOT default), remove videos that have no labeled frames.\n    \"\"\"\n    used_skeletons = []\n    used_tracks = []\n    used_videos = []\n    kept_frames = []\n    for lf in self.labeled_frames:\n\n        if empty_instances:\n            lf.remove_empty_instances()\n\n        if frames and len(lf) == 0:\n            continue\n\n        if videos and lf.video not in used_videos:\n            used_videos.append(lf.video)\n\n        if skeletons or tracks:\n            for inst in lf:\n                if skeletons and inst.skeleton not in used_skeletons:\n                    used_skeletons.append(inst.skeleton)\n                if (\n                    tracks\n                    and inst.track is not None\n                    and inst.track not in used_tracks\n                ):\n                    used_tracks.append(inst.track)\n\n        if frames:\n            kept_frames.append(lf)\n\n    if videos:\n        self.videos = [video for video in self.videos if video in used_videos]\n\n    if skeletons:\n        self.skeletons = [\n            skeleton for skeleton in self.skeletons if skeleton in used_skeletons\n        ]\n\n    if tracks:\n        self.tracks = [track for track in self.tracks if track in used_tracks]\n\n    if frames:\n        self.labeled_frames = kept_frames\n</code></pre>"},{"location":"model/#sleap_io.model.labels.Labels.find","title":"<code>find(video, frame_idx=None, return_new=False)</code>","text":"<p>Search for labeled frames given video and/or frame index.</p> <p>Parameters:</p> Name Type Description Default <code>video</code> <code>Video</code> <p>A <code>Video</code> that is associated with the project.</p> required <code>frame_idx</code> <code>int | list[int] | None</code> <p>The frame index (or indices) which we want to find in the video. If a range is specified, we'll return all frames with indices in that range. If not specific, then we'll return all labeled frames for video.</p> <code>None</code> <code>return_new</code> <code>bool</code> <p>Whether to return singleton of new and empty <code>LabeledFrame</code> if none are found in project.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[LabeledFrame]</code> <p>List of <code>LabeledFrame</code> objects that match the criteria.</p> <p>The list will be empty if no matches found, unless return_new is True, in which case it contains new (empty) <code>LabeledFrame</code> objects with <code>video</code> and <code>frame_index</code> set.</p> Source code in <code>sleap_io/model/labels.py</code> <pre><code>def find(\n    self,\n    video: Video,\n    frame_idx: int | list[int] | None = None,\n    return_new: bool = False,\n) -&gt; list[LabeledFrame]:\n    \"\"\"Search for labeled frames given video and/or frame index.\n\n    Args:\n        video: A `Video` that is associated with the project.\n        frame_idx: The frame index (or indices) which we want to find in the video.\n            If a range is specified, we'll return all frames with indices in that\n            range. If not specific, then we'll return all labeled frames for video.\n        return_new: Whether to return singleton of new and empty `LabeledFrame` if\n            none are found in project.\n\n    Returns:\n        List of `LabeledFrame` objects that match the criteria.\n\n            The list will be empty if no matches found, unless return_new is True,\n            in which case it contains new (empty) `LabeledFrame` objects with `video`\n            and `frame_index` set.\n    \"\"\"\n    results = []\n\n    if frame_idx is None:\n        for lf in self.labeled_frames:\n            if lf.video == video:\n                results.append(lf)\n        return results\n\n    if np.isscalar(frame_idx):\n        frame_idx = np.array(frame_idx).reshape(-1)\n\n    for frame_ind in frame_idx:\n        result = None\n        for lf in self.labeled_frames:\n            if lf.video == video and lf.frame_idx == frame_ind:\n                result = lf\n                results.append(result)\n                break\n        if result is None and return_new:\n            results.append(LabeledFrame(video=video, frame_idx=frame_ind))\n\n    return results\n</code></pre>"},{"location":"model/#sleap_io.model.labels.Labels.numpy","title":"<code>numpy(video=None, all_frames=True, untracked=False, return_confidence=False)</code>","text":"<p>Construct a numpy array from instance points.</p> <p>Parameters:</p> Name Type Description Default <code>video</code> <code>Optional[Union[Video, int]]</code> <p>Video or video index to convert to numpy arrays. If <code>None</code> (the default), uses the first video.</p> <code>None</code> <code>untracked</code> <code>bool</code> <p>If <code>False</code> (the default), include only instances that have a track assignment. If <code>True</code>, includes all instances in each frame in arbitrary order.</p> <code>False</code> <code>return_confidence</code> <code>bool</code> <p>If <code>False</code> (the default), only return points of nodes. If <code>True</code>, return the points and scores of nodes.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>An array of tracks of shape <code>(n_frames, n_tracks, n_nodes, 2)</code> if</p> <code>ndarray</code> <p><code>return_confidence</code> is <code>False</code>. Otherwise returned shape is</p> <code>ndarray</code> <p><code>(n_frames, n_tracks, n_nodes, 3)</code> if <code>return_confidence</code> is <code>True</code>.</p> <code>ndarray</code> <p>Missing data will be replaced with <code>np.nan</code>.</p> <code>ndarray</code> <p>If this is a single instance project, a track does not need to be assigned.</p> <code>ndarray</code> <p>Only predicted instances (NOT user instances) will be returned.</p> Notes <p>This method assumes that instances have tracks assigned and is intended to function primarily for single-video prediction results.</p> Source code in <code>sleap_io/model/labels.py</code> <pre><code>def numpy(\n    self,\n    video: Optional[Union[Video, int]] = None,\n    all_frames: bool = True,\n    untracked: bool = False,\n    return_confidence: bool = False,\n) -&gt; np.ndarray:\n    \"\"\"Construct a numpy array from instance points.\n\n    Args:\n        video: Video or video index to convert to numpy arrays. If `None` (the\n            default), uses the first video.\n        untracked: If `False` (the default), include only instances that have a\n            track assignment. If `True`, includes all instances in each frame in\n            arbitrary order.\n        return_confidence: If `False` (the default), only return points of nodes. If\n            `True`, return the points and scores of nodes.\n\n    Returns:\n        An array of tracks of shape `(n_frames, n_tracks, n_nodes, 2)` if\n        `return_confidence` is `False`. Otherwise returned shape is\n        `(n_frames, n_tracks, n_nodes, 3)` if `return_confidence` is `True`.\n\n        Missing data will be replaced with `np.nan`.\n\n        If this is a single instance project, a track does not need to be assigned.\n\n        Only predicted instances (NOT user instances) will be returned.\n\n    Notes:\n        This method assumes that instances have tracks assigned and is intended to\n        function primarily for single-video prediction results.\n    \"\"\"\n    # Get labeled frames for specified video.\n    if video is None:\n        video = 0\n    if type(video) == int:\n        video = self.videos[video]\n    lfs = [lf for lf in self.labeled_frames if lf.video == video]\n\n    # Figure out frame index range.\n    first_frame, last_frame = 0, 0\n    for lf in lfs:\n        first_frame = min(first_frame, lf.frame_idx)\n        last_frame = max(last_frame, lf.frame_idx)\n\n    # Figure out the number of tracks based on number of instances in each frame.\n    # First, let's check the max number of predicted instances (regardless of\n    # whether they're tracked.\n    n_preds = 0\n    for lf in lfs:\n        n_pred_instances = len(lf.predicted_instances)\n        n_preds = max(n_preds, n_pred_instances)\n\n    # Case 1: We don't care about order because there's only 1 instance per frame,\n    # or we're considering untracked instances.\n    untracked = untracked or n_preds == 1\n    if untracked:\n        n_tracks = n_preds\n    else:\n        # Case 2: We're considering only tracked instances.\n        n_tracks = len(self.tracks)\n\n    n_frames = int(last_frame - first_frame + 1)\n    skeleton = self.skeletons[-1]  # Assume project only uses last skeleton\n    n_nodes = len(skeleton.nodes)\n\n    if return_confidence:\n        tracks = np.full((n_frames, n_tracks, n_nodes, 3), np.nan, dtype=\"float32\")\n    else:\n        tracks = np.full((n_frames, n_tracks, n_nodes, 2), np.nan, dtype=\"float32\")\n    for lf in lfs:\n        i = int(lf.frame_idx - first_frame)\n        if untracked:\n            for j, inst in enumerate(lf.predicted_instances):\n                tracks[i, j] = inst.numpy(scores=return_confidence)\n        else:\n            tracked_instances = [\n                inst\n                for inst in lf.instances\n                if type(inst) == PredictedInstance and inst.track is not None\n            ]\n            for inst in tracked_instances:\n                j = self.tracks.index(inst.track)  # type: ignore[arg-type]\n                tracks[i, j] = inst.numpy(scores=return_confidence)\n\n    return tracks\n</code></pre>"},{"location":"model/#sleap_io.model.labels.Labels.remove_predictions","title":"<code>remove_predictions(clean=True)</code>","text":"<p>Remove all predicted instances from the labels.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If <code>True</code> (the default), also remove any empty frames and unused tracks and skeletons. It does NOT remove videos that have no labeled frames or instances with no visible points.</p> <code>True</code> <p>See also: <code>Labels.clean</code></p> Source code in <code>sleap_io/model/labels.py</code> <pre><code>def remove_predictions(self, clean: bool = True):\n    \"\"\"Remove all predicted instances from the labels.\n\n    Args:\n        clean: If `True` (the default), also remove any empty frames and unused\n            tracks and skeletons. It does NOT remove videos that have no labeled\n            frames or instances with no visible points.\n\n    See also: `Labels.clean`\n    \"\"\"\n    for lf in self.labeled_frames:\n        lf.remove_predictions()\n\n    if clean:\n        self.clean(\n            frames=True,\n            empty_instances=False,\n            skeletons=True,\n            tracks=True,\n            videos=False,\n        )\n</code></pre>"},{"location":"model/#sleap_io.model.labels.Labels.save","title":"<code>save(filename, format=None, **kwargs)</code>","text":"<p>Save labels to file in specified format.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to save labels to.</p> required <code>format</code> <code>Optional[str]</code> <p>The format to save the labels in. If <code>None</code>, the format will be inferred from the file extension. Available formats are \"slp\", \"nwb\", \"labelstudio\", and \"jabs\".</p> <code>None</code> Source code in <code>sleap_io/model/labels.py</code> <pre><code>def save(self, filename: str, format: Optional[str] = None, **kwargs):\n    \"\"\"Save labels to file in specified format.\n\n    Args:\n        filename: Path to save labels to.\n        format: The format to save the labels in. If `None`, the format will be\n            inferred from the file extension. Available formats are \"slp\", \"nwb\",\n            \"labelstudio\", and \"jabs\".\n    \"\"\"\n    from sleap_io import save_file\n\n    save_file(self, filename, format=format, **kwargs)\n</code></pre>"},{"location":"model/#sleap_io.model.labeled_frame","title":"<code>sleap_io.model.labeled_frame</code>","text":"<p>Data structures for data contained within a single video frame.</p> <p>The <code>LabeledFrame</code> class is a data structure that contains <code>Instance</code>s and <code>PredictedInstance</code>s that are associated with a single frame within a video.</p>"},{"location":"model/#sleap_io.model.labeled_frame.LabeledFrame","title":"<code>LabeledFrame</code>","text":"<p>Labeled data for a single frame of a video.</p> <p>Parameters:</p> Name Type Description Default <code>video</code> <p>The :class:<code>Video</code> associated with this <code>LabeledFrame</code>.</p> required <code>frame_idx</code> <p>The index of the <code>LabeledFrame</code> in the <code>Video</code>.</p> required <code>instances</code> <p>List of <code>Instance</code> objects associated with this <code>LabeledFrame</code>.</p> required Source code in <code>sleap_io/model/labeled_frame.py</code> <pre><code>@define(auto_attribs=True)\nclass LabeledFrame:\n    \"\"\"Labeled data for a single frame of a video.\n\n    Args:\n        video: The :class:`Video` associated with this `LabeledFrame`.\n        frame_idx: The index of the `LabeledFrame` in the `Video`.\n        instances: List of `Instance` objects associated with this `LabeledFrame`.\n    \"\"\"\n\n    video: Video\n    frame_idx: int\n    instances: list[Union[Instance, PredictedInstance]] = field(factory=list)\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return the number of instances in the frame.\"\"\"\n        return len(self.instances)\n\n    def __getitem__(self, key: int) -&gt; Union[Instance, PredictedInstance]:\n        \"\"\"Return the `Instance` at `key` index in the `instances` list.\"\"\"\n        return self.instances[key]\n\n    def __iter__(self):\n        \"\"\"Iterate over `Instance`s in `instances` list.\"\"\"\n        return iter(self.instances)\n\n    @property\n    def user_instances(self) -&gt; list[Instance]:\n        \"\"\"Frame instances that are user-labeled (`Instance` objects).\"\"\"\n        return [inst for inst in self.instances if type(inst) == Instance]\n\n    @property\n    def predicted_instances(self) -&gt; list[Instance]:\n        \"\"\"Frame instances that are predicted by a model (`PredictedInstance` objects).\"\"\"\n        return [inst for inst in self.instances if type(inst) == PredictedInstance]\n\n    def numpy(self) -&gt; np.ndarray:\n        \"\"\"Return all instances in the frame as a numpy array.\n\n        Returns:\n            Points as a numpy array of shape `(n_instances, n_nodes, 2)`.\n\n            Note that the order of the instances is arbitrary.\n        \"\"\"\n        n_instances = len(self.instances)\n        n_nodes = len(self.instances[0]) if n_instances &gt; 0 else 0\n        pts = np.full((n_instances, n_nodes, 2), np.nan)\n        for i, inst in enumerate(self.instances):\n            pts[i] = inst.numpy()[:, 0:2]\n        return pts\n\n    @property\n    def image(self) -&gt; np.ndarray:\n        \"\"\"Return the image of the frame as a numpy array.\"\"\"\n        return self.video[self.frame_idx]\n\n    @property\n    def unused_predictions(self) -&gt; list[Instance]:\n        \"\"\"Return a list of \"unused\" `PredictedInstance` objects in frame.\n\n        This is all of the `PredictedInstance` objects which do not have a corresponding\n        `Instance` in the same track in the same frame.\n        \"\"\"\n        unused_predictions = []\n        any_tracks = [inst.track for inst in self.instances if inst.track is not None]\n        if len(any_tracks):\n            # Use tracks to determine which predicted instances have been used\n            used_tracks = [\n                inst.track\n                for inst in self.instances\n                if type(inst) == Instance and inst.track is not None\n            ]\n            unused_predictions = [\n                inst\n                for inst in self.instances\n                if inst.track not in used_tracks and type(inst) == PredictedInstance\n            ]\n\n        else:\n            # Use from_predicted to determine which predicted instances have been used\n            # TODO: should we always do this instead of using tracks?\n            used_instances = [\n                inst.from_predicted\n                for inst in self.instances\n                if inst.from_predicted is not None\n            ]\n            unused_predictions = [\n                inst\n                for inst in self.instances\n                if type(inst) == PredictedInstance and inst not in used_instances\n            ]\n\n        return unused_predictions\n\n    def remove_predictions(self):\n        \"\"\"Remove all `PredictedInstance` objects from the frame.\"\"\"\n        self.instances = [inst for inst in self.instances if type(inst) == Instance]\n\n    def remove_empty_instances(self):\n        \"\"\"Remove all instances with no visible points.\"\"\"\n        self.instances = [inst for inst in self.instances if not inst.is_empty]\n</code></pre>"},{"location":"model/#sleap_io.model.labeled_frame.LabeledFrame.image","title":"<code>image: np.ndarray</code>  <code>property</code>","text":"<p>Return the image of the frame as a numpy array.</p>"},{"location":"model/#sleap_io.model.labeled_frame.LabeledFrame.predicted_instances","title":"<code>predicted_instances: list[Instance]</code>  <code>property</code>","text":"<p>Frame instances that are predicted by a model (<code>PredictedInstance</code> objects).</p>"},{"location":"model/#sleap_io.model.labeled_frame.LabeledFrame.unused_predictions","title":"<code>unused_predictions: list[Instance]</code>  <code>property</code>","text":"<p>Return a list of \"unused\" <code>PredictedInstance</code> objects in frame.</p> <p>This is all of the <code>PredictedInstance</code> objects which do not have a corresponding <code>Instance</code> in the same track in the same frame.</p>"},{"location":"model/#sleap_io.model.labeled_frame.LabeledFrame.user_instances","title":"<code>user_instances: list[Instance]</code>  <code>property</code>","text":"<p>Frame instances that are user-labeled (<code>Instance</code> objects).</p>"},{"location":"model/#sleap_io.model.labeled_frame.LabeledFrame.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Return the <code>Instance</code> at <code>key</code> index in the <code>instances</code> list.</p> Source code in <code>sleap_io/model/labeled_frame.py</code> <pre><code>def __getitem__(self, key: int) -&gt; Union[Instance, PredictedInstance]:\n    \"\"\"Return the `Instance` at `key` index in the `instances` list.\"\"\"\n    return self.instances[key]\n</code></pre>"},{"location":"model/#sleap_io.model.labeled_frame.LabeledFrame.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate over <code>Instance</code>s in <code>instances</code> list.</p> Source code in <code>sleap_io/model/labeled_frame.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over `Instance`s in `instances` list.\"\"\"\n    return iter(self.instances)\n</code></pre>"},{"location":"model/#sleap_io.model.labeled_frame.LabeledFrame.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of instances in the frame.</p> Source code in <code>sleap_io/model/labeled_frame.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return the number of instances in the frame.\"\"\"\n    return len(self.instances)\n</code></pre>"},{"location":"model/#sleap_io.model.labeled_frame.LabeledFrame.numpy","title":"<code>numpy()</code>","text":"<p>Return all instances in the frame as a numpy array.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Points as a numpy array of shape <code>(n_instances, n_nodes, 2)</code>.</p> <code>ndarray</code> <p>Note that the order of the instances is arbitrary.</p> Source code in <code>sleap_io/model/labeled_frame.py</code> <pre><code>def numpy(self) -&gt; np.ndarray:\n    \"\"\"Return all instances in the frame as a numpy array.\n\n    Returns:\n        Points as a numpy array of shape `(n_instances, n_nodes, 2)`.\n\n        Note that the order of the instances is arbitrary.\n    \"\"\"\n    n_instances = len(self.instances)\n    n_nodes = len(self.instances[0]) if n_instances &gt; 0 else 0\n    pts = np.full((n_instances, n_nodes, 2), np.nan)\n    for i, inst in enumerate(self.instances):\n        pts[i] = inst.numpy()[:, 0:2]\n    return pts\n</code></pre>"},{"location":"model/#sleap_io.model.labeled_frame.LabeledFrame.remove_empty_instances","title":"<code>remove_empty_instances()</code>","text":"<p>Remove all instances with no visible points.</p> Source code in <code>sleap_io/model/labeled_frame.py</code> <pre><code>def remove_empty_instances(self):\n    \"\"\"Remove all instances with no visible points.\"\"\"\n    self.instances = [inst for inst in self.instances if not inst.is_empty]\n</code></pre>"},{"location":"model/#sleap_io.model.labeled_frame.LabeledFrame.remove_predictions","title":"<code>remove_predictions()</code>","text":"<p>Remove all <code>PredictedInstance</code> objects from the frame.</p> Source code in <code>sleap_io/model/labeled_frame.py</code> <pre><code>def remove_predictions(self):\n    \"\"\"Remove all `PredictedInstance` objects from the frame.\"\"\"\n    self.instances = [inst for inst in self.instances if type(inst) == Instance]\n</code></pre>"},{"location":"model/#sleap_io.model.instance","title":"<code>sleap_io.model.instance</code>","text":"<p>Data structures for data associated with a single instance such as an animal.</p> <p>The <code>Instance</code> class is a SLEAP data structure that contains a collection of <code>Point</code>s that correspond to landmarks within a <code>Skeleton</code>.</p> <p><code>PredictedInstance</code> additionally contains metadata associated with how the instance was estimated, such as confidence scores.</p>"},{"location":"model/#sleap_io.model.instance.Instance","title":"<code>Instance</code>","text":"<p>This class represents a ground truth instance such as an animal.</p> <p>An <code>Instance</code> has a set of landmarks (<code>Point</code>s) that correspond to the nodes defined in its <code>Skeleton</code>.</p> <p>It may also be associated with a <code>Track</code> which links multiple instances together across frames or videos.</p> <p>Attributes:</p> Name Type Description <code>points</code> <code>Union[dict[Node, Point], dict[Node, PredictedPoint]]</code> <p>A dictionary with keys as <code>Node</code>s and values as <code>Point</code>s containing all of the landmarks of the instance. This can also be specified as a dictionary with node names, a list of length <code>n_nodes</code>, or a numpy array of shape <code>(n_nodes, 2)</code>.</p> <code>skeleton</code> <code>Skeleton</code> <p>The <code>Skeleton</code> that describes the <code>Node</code>s and <code>Edge</code>s associated with this instance.</p> <code>track</code> <code>Optional[Track]</code> <p>An optional <code>Track</code> associated with a unique animal/object across frames or videos.</p> <code>from_predicted</code> <code>Optional[PredictedInstance]</code> <p>The <code>PredictedInstance</code> (if any) that this instance was initialized from. This is used with human-in-the-loop workflows.</p> Source code in <code>sleap_io/model/instance.py</code> <pre><code>@define(auto_attribs=True, slots=True, eq=True)\nclass Instance:\n    \"\"\"This class represents a ground truth instance such as an animal.\n\n    An `Instance` has a set of landmarks (`Point`s) that correspond to the nodes defined\n    in its `Skeleton`.\n\n    It may also be associated with a `Track` which links multiple instances together\n    across frames or videos.\n\n    Attributes:\n        points: A dictionary with keys as `Node`s and values as `Point`s containing all\n            of the landmarks of the instance. This can also be specified as a dictionary\n            with node names, a list of length `n_nodes`, or a numpy array of shape\n            `(n_nodes, 2)`.\n        skeleton: The `Skeleton` that describes the `Node`s and `Edge`s associated with\n            this instance.\n        track: An optional `Track` associated with a unique animal/object across frames\n            or videos.\n        from_predicted: The `PredictedInstance` (if any) that this instance was\n            initialized from. This is used with human-in-the-loop workflows.\n    \"\"\"\n\n    _POINT_TYPE = Point\n\n    def _make_default_point(self, x, y):\n        return self._POINT_TYPE(x, y, visible=not (math.isnan(x) or math.isnan(y)))\n\n    def _convert_points(self, attr, points):\n        \"\"\"Maintain points mappings between nodes and points.\"\"\"\n        if type(points) == np.ndarray:\n            points = points.tolist()\n\n        if type(points) == list:\n            if len(points) != len(self.skeleton):\n                raise ValueError(\n                    \"If specifying points as a list, must provide as many points as \"\n                    \"nodes in the skeleton.\"\n                )\n            points = {node: pt for node, pt in zip(self.skeleton.nodes, points)}\n\n        if type(points) == dict:\n            keys = [\n                node if type(node) == Node else self.skeleton[node]\n                for node in points.keys()\n            ]\n            vals = [\n                (\n                    point\n                    if type(point) == self._POINT_TYPE\n                    else self._make_default_point(*point)\n                )\n                for point in points.values()\n            ]\n            points = {k: v for k, v in zip(keys, vals)}\n\n        missing_nodes = list(set(self.skeleton.nodes) - set(points.keys()))\n        for node in missing_nodes:\n            points[node] = self._make_default_point(x=np.nan, y=np.nan)\n\n        return points\n\n    points: Union[dict[Node, Point], dict[Node, PredictedPoint]] = field(\n        on_setattr=_convert_points, eq=cmp_using(eq=_compare_points)  # type: ignore\n    )\n    skeleton: Skeleton\n    track: Optional[Track] = None\n    from_predicted: Optional[PredictedInstance] = None\n\n    def __attrs_post_init__(self):\n        \"\"\"Maintain point mappings between node and points after initialization.\"\"\"\n        super().__setattr__(\"points\", self._convert_points(None, self.points))\n\n    def __getitem__(self, node: Union[int, str, Node]) -&gt; Optional[Point]:\n        \"\"\"Return the point associated with a node or `None` if not set.\"\"\"\n        if (type(node) == int) or (type(node) == str):\n            node = self.skeleton[node]\n        if isinstance(node, Node):\n            return self.points.get(node, None)\n        else:\n            raise IndexError(f\"Invalid indexing argument for instance: {node}\")\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return the number of points in the instance.\"\"\"\n        return len(self.points)\n\n    @property\n    def n_visible(self) -&gt; int:\n        \"\"\"Return the number of visible points in the instance.\"\"\"\n        return sum(pt.visible for pt in self.points.values())\n\n    @property\n    def is_empty(self) -&gt; bool:\n        \"\"\"Return `True` if no points are visible on the instance.\"\"\"\n        return self.n_visible == 0\n\n    @classmethod\n    def from_numpy(\n        cls, points: np.ndarray, skeleton: Skeleton, track: Optional[Track] = None\n    ) -&gt; \"Instance\":\n        \"\"\"Create an instance object from a numpy array.\n\n        Args:\n            points: A numpy array of shape `(n_nodes, 2)` corresponding to the points of\n                the skeleton. Values of `np.nan` indicate \"missing\" nodes.\n            skeleton: The `Skeleton` that this `Instance` is associated with. It should\n                have `n_nodes` nodes.\n            track: An optional `Track` associated with a unique animal/object across\n                frames or videos.\n        \"\"\"\n        return cls(\n            points=points, skeleton=skeleton, track=track  # type: ignore[arg-type]\n        )\n\n    def numpy(self) -&gt; np.ndarray:\n        \"\"\"Return the instance points as a numpy array.\"\"\"\n        pts = np.full((len(self.skeleton), 2), np.nan)\n        for node, point in self.points.items():\n            if point.visible:\n                pts[self.skeleton.index(node)] = point.numpy()\n        return pts\n</code></pre>"},{"location":"model/#sleap_io.model.instance.Instance.is_empty","title":"<code>is_empty: bool</code>  <code>property</code>","text":"<p>Return <code>True</code> if no points are visible on the instance.</p>"},{"location":"model/#sleap_io.model.instance.Instance.n_visible","title":"<code>n_visible: int</code>  <code>property</code>","text":"<p>Return the number of visible points in the instance.</p>"},{"location":"model/#sleap_io.model.instance.Instance.__attrs_post_init__","title":"<code>__attrs_post_init__()</code>","text":"<p>Maintain point mappings between node and points after initialization.</p> Source code in <code>sleap_io/model/instance.py</code> <pre><code>def __attrs_post_init__(self):\n    \"\"\"Maintain point mappings between node and points after initialization.\"\"\"\n    super().__setattr__(\"points\", self._convert_points(None, self.points))\n</code></pre>"},{"location":"model/#sleap_io.model.instance.Instance.__getitem__","title":"<code>__getitem__(node)</code>","text":"<p>Return the point associated with a node or <code>None</code> if not set.</p> Source code in <code>sleap_io/model/instance.py</code> <pre><code>def __getitem__(self, node: Union[int, str, Node]) -&gt; Optional[Point]:\n    \"\"\"Return the point associated with a node or `None` if not set.\"\"\"\n    if (type(node) == int) or (type(node) == str):\n        node = self.skeleton[node]\n    if isinstance(node, Node):\n        return self.points.get(node, None)\n    else:\n        raise IndexError(f\"Invalid indexing argument for instance: {node}\")\n</code></pre>"},{"location":"model/#sleap_io.model.instance.Instance.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of points in the instance.</p> Source code in <code>sleap_io/model/instance.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return the number of points in the instance.\"\"\"\n    return len(self.points)\n</code></pre>"},{"location":"model/#sleap_io.model.instance.Instance.from_numpy","title":"<code>from_numpy(points, skeleton, track=None)</code>  <code>classmethod</code>","text":"<p>Create an instance object from a numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>ndarray</code> <p>A numpy array of shape <code>(n_nodes, 2)</code> corresponding to the points of the skeleton. Values of <code>np.nan</code> indicate \"missing\" nodes.</p> required <code>skeleton</code> <code>Skeleton</code> <p>The <code>Skeleton</code> that this <code>Instance</code> is associated with. It should have <code>n_nodes</code> nodes.</p> required <code>track</code> <code>Optional[Track]</code> <p>An optional <code>Track</code> associated with a unique animal/object across frames or videos.</p> <code>None</code> Source code in <code>sleap_io/model/instance.py</code> <pre><code>@classmethod\ndef from_numpy(\n    cls, points: np.ndarray, skeleton: Skeleton, track: Optional[Track] = None\n) -&gt; \"Instance\":\n    \"\"\"Create an instance object from a numpy array.\n\n    Args:\n        points: A numpy array of shape `(n_nodes, 2)` corresponding to the points of\n            the skeleton. Values of `np.nan` indicate \"missing\" nodes.\n        skeleton: The `Skeleton` that this `Instance` is associated with. It should\n            have `n_nodes` nodes.\n        track: An optional `Track` associated with a unique animal/object across\n            frames or videos.\n    \"\"\"\n    return cls(\n        points=points, skeleton=skeleton, track=track  # type: ignore[arg-type]\n    )\n</code></pre>"},{"location":"model/#sleap_io.model.instance.Instance.numpy","title":"<code>numpy()</code>","text":"<p>Return the instance points as a numpy array.</p> Source code in <code>sleap_io/model/instance.py</code> <pre><code>def numpy(self) -&gt; np.ndarray:\n    \"\"\"Return the instance points as a numpy array.\"\"\"\n    pts = np.full((len(self.skeleton), 2), np.nan)\n    for node, point in self.points.items():\n        if point.visible:\n            pts[self.skeleton.index(node)] = point.numpy()\n    return pts\n</code></pre>"},{"location":"model/#sleap_io.model.instance.Point","title":"<code>Point</code>","text":"<p>A 2D spatial landmark and metadata associated with annotation.</p> <p>Attributes:</p> Name Type Description <code>x</code> <code>float</code> <p>The horizontal pixel location of point in image coordinates.</p> <code>y</code> <code>float</code> <p>The vertical pixel location of point in image coordinates.</p> <code>visible</code> <code>bool</code> <p>Whether point is visible in the image or not.</p> <code>complete</code> <code>bool</code> <p>Has the point been verified by the user labeler.</p> Class variables <p>eq_atol: Controls absolute tolerence allowed in <code>x</code> and <code>y</code> when comparing two     <code>Point</code>s for equality. eq_rtol: Controls relative tolerence allowed in <code>x</code> and <code>y</code> when comparing two     <code>Point</code>s for equality.</p> Source code in <code>sleap_io/model/instance.py</code> <pre><code>@define\nclass Point:\n    \"\"\"A 2D spatial landmark and metadata associated with annotation.\n\n    Attributes:\n        x: The horizontal pixel location of point in image coordinates.\n        y: The vertical pixel location of point in image coordinates.\n        visible: Whether point is visible in the image or not.\n        complete: Has the point been verified by the user labeler.\n\n    Class variables:\n        eq_atol: Controls absolute tolerence allowed in `x` and `y` when comparing two\n            `Point`s for equality.\n        eq_rtol: Controls relative tolerence allowed in `x` and `y` when comparing two\n            `Point`s for equality.\n\n    \"\"\"\n\n    eq_atol: ClassVar[float] = 1e-08\n    eq_rtol: ClassVar[float] = 0\n\n    x: float\n    y: float\n    visible: bool = True\n    complete: bool = False\n\n    def __eq__(self, other: object):\n        \"\"\"Compare `self` and `other` for equality.\n\n        Precision error between the respective `x` and `y` properties of two\n        instances may be allowed or controlled via the `Point.eq_atol` and\n        `Point.eq_rtol` class variables. Set to zero to disable their effect.\n        Internally, `numpy.isclose()` is used for the comparison:\n        https://numpy.org/doc/stable/reference/generated/numpy.isclose.html\n\n        Args:\n            other: Instance of `Point` to compare to.\n\n        Returns:\n            True if all attributes of `self` and `other` are the identical (possibly\n            allowing precision error for `x` and `y` attributes).\n        \"\"\"\n        # Check that other is a Point.\n        if type(other) is not type(self):\n            return False\n\n        # We know that we have some kind of point at this point.\n        other = cast(Point, other)\n\n        return bool(\n            np.all(\n                np.isclose(\n                    [self.x, self.y],\n                    [other.x, other.y],\n                    rtol=Point.eq_rtol,\n                    atol=Point.eq_atol,\n                    equal_nan=True,\n                )\n            )\n            and (self.visible == other.visible)\n            and (self.complete == other.complete)\n        )\n\n    def numpy(self) -&gt; np.ndarray:\n        \"\"\"Return the coordinates as a numpy array of shape `(2,)`.\"\"\"\n        return np.array([self.x, self.y]) if self.visible else np.full((2,), np.nan)\n</code></pre>"},{"location":"model/#sleap_io.model.instance.Point.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Compare <code>self</code> and <code>other</code> for equality.</p> <p>Precision error between the respective <code>x</code> and <code>y</code> properties of two instances may be allowed or controlled via the <code>Point.eq_atol</code> and <code>Point.eq_rtol</code> class variables. Set to zero to disable their effect. Internally, <code>numpy.isclose()</code> is used for the comparison: https://numpy.org/doc/stable/reference/generated/numpy.isclose.html</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>object</code> <p>Instance of <code>Point</code> to compare to.</p> required <p>Returns:</p> Type Description <p>True if all attributes of <code>self</code> and <code>other</code> are the identical (possibly</p> <p>allowing precision error for <code>x</code> and <code>y</code> attributes).</p> Source code in <code>sleap_io/model/instance.py</code> <pre><code>def __eq__(self, other: object):\n    \"\"\"Compare `self` and `other` for equality.\n\n    Precision error between the respective `x` and `y` properties of two\n    instances may be allowed or controlled via the `Point.eq_atol` and\n    `Point.eq_rtol` class variables. Set to zero to disable their effect.\n    Internally, `numpy.isclose()` is used for the comparison:\n    https://numpy.org/doc/stable/reference/generated/numpy.isclose.html\n\n    Args:\n        other: Instance of `Point` to compare to.\n\n    Returns:\n        True if all attributes of `self` and `other` are the identical (possibly\n        allowing precision error for `x` and `y` attributes).\n    \"\"\"\n    # Check that other is a Point.\n    if type(other) is not type(self):\n        return False\n\n    # We know that we have some kind of point at this point.\n    other = cast(Point, other)\n\n    return bool(\n        np.all(\n            np.isclose(\n                [self.x, self.y],\n                [other.x, other.y],\n                rtol=Point.eq_rtol,\n                atol=Point.eq_atol,\n                equal_nan=True,\n            )\n        )\n        and (self.visible == other.visible)\n        and (self.complete == other.complete)\n    )\n</code></pre>"},{"location":"model/#sleap_io.model.instance.Point.numpy","title":"<code>numpy()</code>","text":"<p>Return the coordinates as a numpy array of shape <code>(2,)</code>.</p> Source code in <code>sleap_io/model/instance.py</code> <pre><code>def numpy(self) -&gt; np.ndarray:\n    \"\"\"Return the coordinates as a numpy array of shape `(2,)`.\"\"\"\n    return np.array([self.x, self.y]) if self.visible else np.full((2,), np.nan)\n</code></pre>"},{"location":"model/#sleap_io.model.instance.PredictedInstance","title":"<code>PredictedInstance</code>","text":"<p>             Bases: <code>Instance</code></p> <p>A <code>PredictedInstance</code> is an <code>Instance</code> that was predicted using a model.</p> <p>Parameters:</p> Name Type Description Default <code>skeleton</code> <p>The <code>Skeleton</code> that this <code>Instance</code> is associated with.</p> required <code>points</code> <p>A dictionary where keys are <code>Skeleton</code> nodes and values are <code>Point</code>s.</p> required <code>track</code> <p>An optional <code>Track</code> associated with a unique animal/object across frames or videos.</p> required <code>from_predicted</code> <p>Not applicable in <code>PredictedInstance</code>s (must be set to <code>None</code>).</p> required <code>score</code> <p>The instance detection or part grouping prediction score. This is a scalar that represents the confidence with which this entire instance was predicted. This may not always be applicable depending on the model type.</p> required <code>tracking_score</code> <p>The score associated with the <code>Track</code> assignment. This is typically the value from the score matrix used in an identity assignment.</p> required Source code in <code>sleap_io/model/instance.py</code> <pre><code>@define\nclass PredictedInstance(Instance):\n    \"\"\"A `PredictedInstance` is an `Instance` that was predicted using a model.\n\n    Args:\n        skeleton: The `Skeleton` that this `Instance` is associated with.\n        points: A dictionary where keys are `Skeleton` nodes and values are `Point`s.\n        track: An optional `Track` associated with a unique animal/object across frames\n            or videos.\n        from_predicted: Not applicable in `PredictedInstance`s (must be set to `None`).\n        score: The instance detection or part grouping prediction score. This is a\n            scalar that represents the confidence with which this entire instance was\n            predicted. This may not always be applicable depending on the model type.\n        tracking_score: The score associated with the `Track` assignment. This is\n            typically the value from the score matrix used in an identity assignment.\n    \"\"\"\n\n    _POINT_TYPE = PredictedPoint\n\n    from_predicted: Optional[PredictedInstance] = field(\n        default=None, validator=validators.instance_of(type(None))\n    )\n    score: float = 0.0\n    tracking_score: Optional[float] = 0\n\n    @classmethod\n    def from_numpy(  # type: ignore[override]\n        cls,\n        points: np.ndarray,\n        point_scores: np.ndarray,\n        instance_score: float,\n        skeleton: Skeleton,\n        tracking_score: Optional[float] = None,\n        track: Optional[Track] = None,\n    ) -&gt; \"PredictedInstance\":\n        \"\"\"Create an instance object from a numpy array.\n\n        Args:\n            points: A numpy array of shape `(n_nodes, 2)` corresponding to the points of\n                the skeleton. Values of `np.nan` indicate \"missing\" nodes.\n            point_scores: The points-level prediction score. This is an array that\n                represents the confidence with which each point in the instance was\n                predicted. This may not always be applicable depending on the model\n                type.\n            instance_score: The instance detection or part grouping prediction score.\n                This is a scalar that represents the confidence with which this entire\n                instance was predicted. This may not always be applicable depending on\n                the model type.\n            skeleton: The `Skeleton` that this `Instance` is associated with. It should\n                have `n_nodes` nodes.\n            tracking_score: The score associated with the `Track` assignment. This is\n                typically the value from the score matrix used in an identity\n                assignment.\n            track: An optional `Track` associated with a unique animal/object across\n                frames or videos.\n        \"\"\"\n        node_points = {\n            node: PredictedPoint(pt[0], pt[1], score=score)\n            for node, pt, score in zip(skeleton.nodes, points, point_scores)\n        }\n        return cls(\n            points=node_points,\n            skeleton=skeleton,\n            score=instance_score,\n            tracking_score=tracking_score,\n            track=track,\n        )\n\n    def numpy(self, scores: bool = False) -&gt; np.ndarray:\n        \"\"\"Return the instance points as a numpy array.\"\"\"\n        pts = np.full((len(self.skeleton), 3), np.nan)\n        for node, point in self.points.items():\n            if point.visible:\n                pts[self.skeleton.index(node)] = point.numpy()\n        if not scores:\n            pts = pts[:, :2]\n        return pts\n</code></pre>"},{"location":"model/#sleap_io.model.instance.PredictedInstance.from_numpy","title":"<code>from_numpy(points, point_scores, instance_score, skeleton, tracking_score=None, track=None)</code>  <code>classmethod</code>","text":"<p>Create an instance object from a numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>ndarray</code> <p>A numpy array of shape <code>(n_nodes, 2)</code> corresponding to the points of the skeleton. Values of <code>np.nan</code> indicate \"missing\" nodes.</p> required <code>point_scores</code> <code>ndarray</code> <p>The points-level prediction score. This is an array that represents the confidence with which each point in the instance was predicted. This may not always be applicable depending on the model type.</p> required <code>instance_score</code> <code>float</code> <p>The instance detection or part grouping prediction score. This is a scalar that represents the confidence with which this entire instance was predicted. This may not always be applicable depending on the model type.</p> required <code>skeleton</code> <code>Skeleton</code> <p>The <code>Skeleton</code> that this <code>Instance</code> is associated with. It should have <code>n_nodes</code> nodes.</p> required <code>tracking_score</code> <code>Optional[float]</code> <p>The score associated with the <code>Track</code> assignment. This is typically the value from the score matrix used in an identity assignment.</p> <code>None</code> <code>track</code> <code>Optional[Track]</code> <p>An optional <code>Track</code> associated with a unique animal/object across frames or videos.</p> <code>None</code> Source code in <code>sleap_io/model/instance.py</code> <pre><code>@classmethod\ndef from_numpy(  # type: ignore[override]\n    cls,\n    points: np.ndarray,\n    point_scores: np.ndarray,\n    instance_score: float,\n    skeleton: Skeleton,\n    tracking_score: Optional[float] = None,\n    track: Optional[Track] = None,\n) -&gt; \"PredictedInstance\":\n    \"\"\"Create an instance object from a numpy array.\n\n    Args:\n        points: A numpy array of shape `(n_nodes, 2)` corresponding to the points of\n            the skeleton. Values of `np.nan` indicate \"missing\" nodes.\n        point_scores: The points-level prediction score. This is an array that\n            represents the confidence with which each point in the instance was\n            predicted. This may not always be applicable depending on the model\n            type.\n        instance_score: The instance detection or part grouping prediction score.\n            This is a scalar that represents the confidence with which this entire\n            instance was predicted. This may not always be applicable depending on\n            the model type.\n        skeleton: The `Skeleton` that this `Instance` is associated with. It should\n            have `n_nodes` nodes.\n        tracking_score: The score associated with the `Track` assignment. This is\n            typically the value from the score matrix used in an identity\n            assignment.\n        track: An optional `Track` associated with a unique animal/object across\n            frames or videos.\n    \"\"\"\n    node_points = {\n        node: PredictedPoint(pt[0], pt[1], score=score)\n        for node, pt, score in zip(skeleton.nodes, points, point_scores)\n    }\n    return cls(\n        points=node_points,\n        skeleton=skeleton,\n        score=instance_score,\n        tracking_score=tracking_score,\n        track=track,\n    )\n</code></pre>"},{"location":"model/#sleap_io.model.instance.PredictedInstance.numpy","title":"<code>numpy(scores=False)</code>","text":"<p>Return the instance points as a numpy array.</p> Source code in <code>sleap_io/model/instance.py</code> <pre><code>def numpy(self, scores: bool = False) -&gt; np.ndarray:\n    \"\"\"Return the instance points as a numpy array.\"\"\"\n    pts = np.full((len(self.skeleton), 3), np.nan)\n    for node, point in self.points.items():\n        if point.visible:\n            pts[self.skeleton.index(node)] = point.numpy()\n    if not scores:\n        pts = pts[:, :2]\n    return pts\n</code></pre>"},{"location":"model/#sleap_io.model.instance.PredictedPoint","title":"<code>PredictedPoint</code>","text":"<p>             Bases: <code>Point</code></p> <p>A predicted point with associated score generated by a prediction model.</p> <p>It has all the properties of a labeled <code>Point</code>, plus a <code>score</code>.</p> <p>Attributes:</p> Name Type Description <code>x</code> <p>The horizontal pixel location of point within image frame.</p> <code>y</code> <p>The vertical pixel location of point within image frame.</p> <code>visible</code> <p>Whether point is visible in the image or not.</p> <code>complete</code> <p>Has the point been verified by the user labeler.</p> <code>score</code> <code>float</code> <p>The point-level prediction score. This is typically the confidence and set to a value between 0 and 1.</p> Source code in <code>sleap_io/model/instance.py</code> <pre><code>@define\nclass PredictedPoint(Point):\n    \"\"\"A predicted point with associated score generated by a prediction model.\n\n    It has all the properties of a labeled `Point`, plus a `score`.\n\n    Attributes:\n        x: The horizontal pixel location of point within image frame.\n        y: The vertical pixel location of point within image frame.\n        visible: Whether point is visible in the image or not.\n        complete: Has the point been verified by the user labeler.\n        score: The point-level prediction score. This is typically the confidence and\n            set to a value between 0 and 1.\n    \"\"\"\n\n    score: float = 0.0\n\n    def numpy(self) -&gt; np.ndarray:\n        \"\"\"Return the coordinates and score as a numpy array of shape `(3,)`.\"\"\"\n        return (\n            np.array([self.x, self.y, self.score])\n            if self.visible\n            else np.full((3,), np.nan)\n        )\n\n    def __eq__(self, other: object):\n        \"\"\"Compare `self` and `other` for equality.\n\n        See `Point.__eq__()` for important notes about point equality semantics!\n\n        Args:\n            self, other: instance of `PredictedPoint` to compare\n\n        Returns:\n            True if all attributes of `self` and `other` are the identical (possibly\n            allowing precision error for `x` and `y` attributes).\n        \"\"\"\n        if not super().__eq__(other):\n            return False\n\n        # we know that we have a point at this point\n        other = cast(PredictedPoint, other)\n\n        return self.score == other.score\n</code></pre>"},{"location":"model/#sleap_io.model.instance.PredictedPoint.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Compare <code>self</code> and <code>other</code> for equality.</p> <p>See <code>Point.__eq__()</code> for important notes about point equality semantics!</p> <p>Parameters:</p> Name Type Description Default <code>self,</code> <code>other</code> <p>instance of <code>PredictedPoint</code> to compare</p> required <p>Returns:</p> Type Description <p>True if all attributes of <code>self</code> and <code>other</code> are the identical (possibly</p> <p>allowing precision error for <code>x</code> and <code>y</code> attributes).</p> Source code in <code>sleap_io/model/instance.py</code> <pre><code>def __eq__(self, other: object):\n    \"\"\"Compare `self` and `other` for equality.\n\n    See `Point.__eq__()` for important notes about point equality semantics!\n\n    Args:\n        self, other: instance of `PredictedPoint` to compare\n\n    Returns:\n        True if all attributes of `self` and `other` are the identical (possibly\n        allowing precision error for `x` and `y` attributes).\n    \"\"\"\n    if not super().__eq__(other):\n        return False\n\n    # we know that we have a point at this point\n    other = cast(PredictedPoint, other)\n\n    return self.score == other.score\n</code></pre>"},{"location":"model/#sleap_io.model.instance.PredictedPoint.numpy","title":"<code>numpy()</code>","text":"<p>Return the coordinates and score as a numpy array of shape <code>(3,)</code>.</p> Source code in <code>sleap_io/model/instance.py</code> <pre><code>def numpy(self) -&gt; np.ndarray:\n    \"\"\"Return the coordinates and score as a numpy array of shape `(3,)`.\"\"\"\n    return (\n        np.array([self.x, self.y, self.score])\n        if self.visible\n        else np.full((3,), np.nan)\n    )\n</code></pre>"},{"location":"model/#sleap_io.model.instance.Track","title":"<code>Track</code>","text":"<p>An object that represents the same animal/object across multiple detections.</p> <p>This allows tracking of unique entities in the video over time and space.</p> <p>A <code>Track</code> may also be used to refer to unique identity classes that span multiple videos, such as <code>\"female mouse\"</code>.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>A name given to this track for identification purposes.</p> Notes <p><code>Track</code>s are compared by identity. This means that unique track objects with the same name are considered to be different.</p> Source code in <code>sleap_io/model/instance.py</code> <pre><code>@define(eq=False)\nclass Track:\n    \"\"\"An object that represents the same animal/object across multiple detections.\n\n    This allows tracking of unique entities in the video over time and space.\n\n    A `Track` may also be used to refer to unique identity classes that span multiple\n    videos, such as `\"female mouse\"`.\n\n    Attributes:\n        name: A name given to this track for identification purposes.\n\n    Notes:\n        `Track`s are compared by identity. This means that unique track objects with the\n        same name are considered to be different.\n    \"\"\"\n\n    name: str = \"\"\n</code></pre>"},{"location":"model/#sleap_io.model.skeleton","title":"<code>sleap_io.model.skeleton</code>","text":"<p>Data model for skeletons.</p> <p>Skeletons are collections of nodes and edges which describe the landmarks associated with a pose model. The edges represent the connections between them and may be used differently depending on the underlying pose model.</p>"},{"location":"model/#sleap_io.model.skeleton.Edge","title":"<code>Edge</code>","text":"<p>A connection between two <code>Node</code> objects within a <code>Skeleton</code>.</p> <p>This is a directed edge, representing the ordering of <code>Node</code>s in the <code>Skeleton</code> tree.</p> <p>Attributes:</p> Name Type Description <code>source</code> <code>Node</code> <p>The origin <code>Node</code>.</p> <code>destination</code> <code>Node</code> <p>The destination <code>Node</code>.</p> Source code in <code>sleap_io/model/skeleton.py</code> <pre><code>@define(frozen=True)\nclass Edge:\n    \"\"\"A connection between two `Node` objects within a `Skeleton`.\n\n    This is a directed edge, representing the ordering of `Node`s in the `Skeleton`\n    tree.\n\n    Attributes:\n        source: The origin `Node`.\n        destination: The destination `Node`.\n    \"\"\"\n\n    source: Node\n    destination: Node\n\n    def __getitem__(self, idx) -&gt; Node:\n        \"\"\"Return the source `Node` (`idx` is 0) or destination `Node` (`idx` is 1).\"\"\"\n        if idx == 0:\n            return self.source\n        elif idx == 1:\n            return self.destination\n        else:\n            raise IndexError(\"Edge only has 2 nodes (source and destination).\")\n</code></pre>"},{"location":"model/#sleap_io.model.skeleton.Edge.__getitem__","title":"<code>__getitem__(idx)</code>","text":"<p>Return the source <code>Node</code> (<code>idx</code> is 0) or destination <code>Node</code> (<code>idx</code> is 1).</p> Source code in <code>sleap_io/model/skeleton.py</code> <pre><code>def __getitem__(self, idx) -&gt; Node:\n    \"\"\"Return the source `Node` (`idx` is 0) or destination `Node` (`idx` is 1).\"\"\"\n    if idx == 0:\n        return self.source\n    elif idx == 1:\n        return self.destination\n    else:\n        raise IndexError(\"Edge only has 2 nodes (source and destination).\")\n</code></pre>"},{"location":"model/#sleap_io.model.skeleton.Node","title":"<code>Node</code>","text":"<p>A landmark type within a <code>Skeleton</code>.</p> <p>This typically corresponds to a unique landmark within a skeleton, such as the \"left eye\".</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Descriptive label for the landmark.</p> Source code in <code>sleap_io/model/skeleton.py</code> <pre><code>@define(frozen=True, cache_hash=True)\nclass Node:\n    \"\"\"A landmark type within a `Skeleton`.\n\n    This typically corresponds to a unique landmark within a skeleton, such as the \"left\n    eye\".\n\n    Attributes:\n        name: Descriptive label for the landmark.\n    \"\"\"\n\n    name: str\n</code></pre>"},{"location":"model/#sleap_io.model.skeleton.Skeleton","title":"<code>Skeleton</code>","text":"<p>A description of a set of landmark types and connections between them.</p> <p>Skeletons are represented by a directed graph composed of a set of <code>Node</code>s (landmark types such as body parts) and <code>Edge</code>s (connections between parts).</p> <p>Attributes:</p> Name Type Description <code>nodes</code> <code>list[Node]</code> <p>A list of <code>Node</code>s. May be specified as a list of strings to create new nodes from their names.</p> <code>edges</code> <code>list[Edge]</code> <p>A list of <code>Edge</code>s. May be specified as a list of 2-tuples of string names or integer indices of <code>nodes</code>. Each edge corresponds to a pair of source and destination nodes forming a directed edge.</p> <code>symmetries</code> <code>list[Symmetry]</code> <p>A list of <code>Symmetry</code>s. Each symmetry corresponds to symmetric body parts, such as <code>\"left eye\", \"right eye\"</code>. This is used when applying flip (reflection) augmentation to images in order to appropriately swap the indices of symmetric landmarks.</p> <code>name</code> <code>Optional[str]</code> <p>A descriptive name for the <code>Skeleton</code>.</p> Source code in <code>sleap_io/model/skeleton.py</code> <pre><code>@define\nclass Skeleton:\n    \"\"\"A description of a set of landmark types and connections between them.\n\n    Skeletons are represented by a directed graph composed of a set of `Node`s (landmark\n    types such as body parts) and `Edge`s (connections between parts).\n\n    Attributes:\n        nodes: A list of `Node`s. May be specified as a list of strings to create new\n            nodes from their names.\n        edges: A list of `Edge`s. May be specified as a list of 2-tuples of string names\n            or integer indices of `nodes`. Each edge corresponds to a pair of source and\n            destination nodes forming a directed edge.\n        symmetries: A list of `Symmetry`s. Each symmetry corresponds to symmetric body\n            parts, such as `\"left eye\", \"right eye\"`. This is used when applying flip\n            (reflection) augmentation to images in order to appropriately swap the\n            indices of symmetric landmarks.\n        name: A descriptive name for the `Skeleton`.\n    \"\"\"\n\n    def _update_node_map(self, attr, nodes):\n        \"\"\"Callback for maintaining node name/index to `Node` map.\"\"\"\n        self._node_name_map = {node.name: node for node in nodes}\n        self._node_ind_map = {node: i for i, node in enumerate(nodes)}\n\n    nodes: list[Node] = field(factory=list, on_setattr=_update_node_map)\n    edges: list[Edge] = field(factory=list)\n    symmetries: list[Symmetry] = field(factory=list)\n    name: Optional[str] = None\n    _node_name_map: dict[str, Node] = field(init=False, repr=False, eq=False)\n    _node_ind_map: dict[Node, int] = field(init=False, repr=False, eq=False)\n\n    def __attrs_post_init__(self):\n        \"\"\"Ensure nodes are `Node`s, edges are `Edge`s, and `Node` map is updated.\"\"\"\n        self._convert_nodes()\n        self._convert_edges()\n        self._update_node_map(None, self.nodes)\n\n    def _convert_nodes(self):\n        \"\"\"Convert nodes to `Node` objects if needed.\"\"\"\n        if isinstance(self.nodes, np.ndarray):\n            object.__setattr__(self, \"nodes\", self.nodes.tolist())\n        for i, node in enumerate(self.nodes):\n            if type(node) == str:\n                self.nodes[i] = Node(node)\n\n    def _convert_edges(self):\n        \"\"\"Convert list of edge names or integers to `Edge` objects if needed.\"\"\"\n        if isinstance(self.edges, np.ndarray):\n            self.edges = self.edges.tolist()\n        node_names = self.node_names\n        for i, edge in enumerate(self.edges):\n            if type(edge) == Edge:\n                continue\n            src, dst = edge\n            if type(src) == str:\n                try:\n                    src = node_names.index(src)\n                except ValueError:\n                    raise ValueError(\n                        f\"Node '{src}' specified in the edge list is not in the nodes.\"\n                    )\n            if type(src) == int or (\n                np.isscalar(src) and np.issubdtype(src.dtype, np.integer)\n            ):\n                src = self.nodes[src]\n\n            if type(dst) == str:\n                try:\n                    dst = node_names.index(dst)\n                except ValueError:\n                    raise ValueError(\n                        f\"Node '{dst}' specified in the edge list is not in the nodes.\"\n                    )\n            if type(dst) == int or (\n                np.isscalar(dst) and np.issubdtype(dst.dtype, np.integer)\n            ):\n                dst = self.nodes[dst]\n\n            self.edges[i] = Edge(src, dst)\n\n    @property\n    def node_names(self) -&gt; list[str]:\n        \"\"\"Names of the nodes associated with this skeleton as a list of strings.\"\"\"\n        return [node.name for node in self.nodes]\n\n    @property\n    def edge_inds(self) -&gt; list[Tuple[int, int]]:\n        \"\"\"Edges indices as a list of 2-tuples.\"\"\"\n        return [\n            (self.nodes.index(edge.source), self.nodes.index(edge.destination))\n            for edge in self.edges\n        ]\n\n    @property\n    def flipped_node_inds(self) -&gt; list[int]:\n        \"\"\"Returns node indices that should be switched when horizontally flipping.\"\"\"\n        flip_idx = np.arange(len(self.nodes))\n        if len(self.symmetries) &gt; 0:\n            symmetry_inds = np.array(\n                [(self.index(a), self.index(b)) for a, b in self.symmetries]\n            )\n            flip_idx[symmetry_inds[:, 0]] = symmetry_inds[:, 1]\n            flip_idx[symmetry_inds[:, 1]] = symmetry_inds[:, 0]\n\n        flip_idx = flip_idx.tolist()\n        return flip_idx\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return the number of nodes in the skeleton.\"\"\"\n        return len(self.nodes)\n\n    def index(self, node: Node | str) -&gt; int:\n        \"\"\"Return the index of a node specified as a `Node` or string name.\"\"\"\n        if type(node) == str:\n            return self.index(self._node_name_map[node])\n        elif type(node) == Node:\n            return self._node_ind_map[node]\n        else:\n            raise IndexError(f\"Invalid indexing argument for skeleton: {node}\")\n\n    def __getitem__(self, idx: int | str) -&gt; Node:\n        \"\"\"Return a `Node` when indexing by name or integer.\"\"\"\n        if type(idx) == int:\n            return self.nodes[idx]\n        elif type(idx) == str:\n            return self._node_name_map[idx]\n        else:\n            raise IndexError(f\"Invalid indexing argument for skeleton: {idx}\")\n\n    def add_node(self, node: Node | str):\n        \"\"\"Add a `Node` to the skeleton.\n\n        Args:\n            node: A `Node` object or a string name to create a new node.\n        \"\"\"\n        if type(node) == str:\n            node = Node(node)\n        if node not in self.nodes:\n            self.nodes.append(node)\n            self._update_node_map(None, self.nodes)\n\n    def add_edge(self, src: Edge | Node | str = None, dst: Node | str = None):\n        \"\"\"Add an `Edge` to the skeleton.\n\n        Args:\n            src: The source `Node` or name of the source node.\n            dst: The destination `Node` or name of the destination node.\n        \"\"\"\n        if type(src) == Edge:\n            edge = src\n            if edge not in self.edges:\n                self.edges.append(edge)\n            if edge.source not in self.nodes:\n                self.add_node(edge.source)\n            if edge.destination not in self.nodes:\n                self.add_node(edge.destination)\n            return\n\n        if type(src) == str or type(src) == Node:\n            try:\n                src = self.index(src)\n            except KeyError:\n                self.add_node(src)\n                src = self.index(src)\n\n        if type(dst) == str or type(dst) == Node:\n            try:\n                dst = self.index(dst)\n            except KeyError:\n                self.add_node(dst)\n                dst = self.index(dst)\n\n        edge = Edge(self.nodes[src], self.nodes[dst])\n        if edge not in self.edges:\n            self.edges.append(edge)\n\n    def add_symmetry(\n        self, node1: Symmetry | Node | str = None, node2: Node | str = None\n    ):\n        \"\"\"Add a symmetry relationship to the skeleton.\n\n        Args:\n            node1: The first `Node` or name of the first node.\n            node2: The second `Node` or name of the second node.\n        \"\"\"\n        if type(node1) == Symmetry:\n            if node1 not in self.symmetries:\n                self.symmetries.append(node1)\n                for node in node1.nodes:\n                    if node not in self.nodes:\n                        self.add_node(node)\n            return\n\n        if type(node1) == str or type(node1) == Node:\n            try:\n                node1 = self.index(node1)\n            except KeyError:\n                self.add_node(node1)\n                node1 = self.index(node1)\n\n        if type(node2) == str or type(node2) == Node:\n            try:\n                node2 = self.index(node2)\n            except KeyError:\n                self.add_node(node2)\n                node2 = self.index(node2)\n\n        symmetry = Symmetry({self.nodes[node1], self.nodes[node2]})\n        if symmetry not in self.symmetries:\n            self.symmetries.append(symmetry)\n</code></pre>"},{"location":"model/#sleap_io.model.skeleton.Skeleton.edge_inds","title":"<code>edge_inds: list[Tuple[int, int]]</code>  <code>property</code>","text":"<p>Edges indices as a list of 2-tuples.</p>"},{"location":"model/#sleap_io.model.skeleton.Skeleton.flipped_node_inds","title":"<code>flipped_node_inds: list[int]</code>  <code>property</code>","text":"<p>Returns node indices that should be switched when horizontally flipping.</p>"},{"location":"model/#sleap_io.model.skeleton.Skeleton.node_names","title":"<code>node_names: list[str]</code>  <code>property</code>","text":"<p>Names of the nodes associated with this skeleton as a list of strings.</p>"},{"location":"model/#sleap_io.model.skeleton.Skeleton.__attrs_post_init__","title":"<code>__attrs_post_init__()</code>","text":"<p>Ensure nodes are <code>Node</code>s, edges are <code>Edge</code>s, and <code>Node</code> map is updated.</p> Source code in <code>sleap_io/model/skeleton.py</code> <pre><code>def __attrs_post_init__(self):\n    \"\"\"Ensure nodes are `Node`s, edges are `Edge`s, and `Node` map is updated.\"\"\"\n    self._convert_nodes()\n    self._convert_edges()\n    self._update_node_map(None, self.nodes)\n</code></pre>"},{"location":"model/#sleap_io.model.skeleton.Skeleton.__getitem__","title":"<code>__getitem__(idx)</code>","text":"<p>Return a <code>Node</code> when indexing by name or integer.</p> Source code in <code>sleap_io/model/skeleton.py</code> <pre><code>def __getitem__(self, idx: int | str) -&gt; Node:\n    \"\"\"Return a `Node` when indexing by name or integer.\"\"\"\n    if type(idx) == int:\n        return self.nodes[idx]\n    elif type(idx) == str:\n        return self._node_name_map[idx]\n    else:\n        raise IndexError(f\"Invalid indexing argument for skeleton: {idx}\")\n</code></pre>"},{"location":"model/#sleap_io.model.skeleton.Skeleton.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of nodes in the skeleton.</p> Source code in <code>sleap_io/model/skeleton.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return the number of nodes in the skeleton.\"\"\"\n    return len(self.nodes)\n</code></pre>"},{"location":"model/#sleap_io.model.skeleton.Skeleton.add_edge","title":"<code>add_edge(src=None, dst=None)</code>","text":"<p>Add an <code>Edge</code> to the skeleton.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>Edge | Node | str</code> <p>The source <code>Node</code> or name of the source node.</p> <code>None</code> <code>dst</code> <code>Node | str</code> <p>The destination <code>Node</code> or name of the destination node.</p> <code>None</code> Source code in <code>sleap_io/model/skeleton.py</code> <pre><code>def add_edge(self, src: Edge | Node | str = None, dst: Node | str = None):\n    \"\"\"Add an `Edge` to the skeleton.\n\n    Args:\n        src: The source `Node` or name of the source node.\n        dst: The destination `Node` or name of the destination node.\n    \"\"\"\n    if type(src) == Edge:\n        edge = src\n        if edge not in self.edges:\n            self.edges.append(edge)\n        if edge.source not in self.nodes:\n            self.add_node(edge.source)\n        if edge.destination not in self.nodes:\n            self.add_node(edge.destination)\n        return\n\n    if type(src) == str or type(src) == Node:\n        try:\n            src = self.index(src)\n        except KeyError:\n            self.add_node(src)\n            src = self.index(src)\n\n    if type(dst) == str or type(dst) == Node:\n        try:\n            dst = self.index(dst)\n        except KeyError:\n            self.add_node(dst)\n            dst = self.index(dst)\n\n    edge = Edge(self.nodes[src], self.nodes[dst])\n    if edge not in self.edges:\n        self.edges.append(edge)\n</code></pre>"},{"location":"model/#sleap_io.model.skeleton.Skeleton.add_node","title":"<code>add_node(node)</code>","text":"<p>Add a <code>Node</code> to the skeleton.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node | str</code> <p>A <code>Node</code> object or a string name to create a new node.</p> required Source code in <code>sleap_io/model/skeleton.py</code> <pre><code>def add_node(self, node: Node | str):\n    \"\"\"Add a `Node` to the skeleton.\n\n    Args:\n        node: A `Node` object or a string name to create a new node.\n    \"\"\"\n    if type(node) == str:\n        node = Node(node)\n    if node not in self.nodes:\n        self.nodes.append(node)\n        self._update_node_map(None, self.nodes)\n</code></pre>"},{"location":"model/#sleap_io.model.skeleton.Skeleton.add_symmetry","title":"<code>add_symmetry(node1=None, node2=None)</code>","text":"<p>Add a symmetry relationship to the skeleton.</p> <p>Parameters:</p> Name Type Description Default <code>node1</code> <code>Symmetry | Node | str</code> <p>The first <code>Node</code> or name of the first node.</p> <code>None</code> <code>node2</code> <code>Node | str</code> <p>The second <code>Node</code> or name of the second node.</p> <code>None</code> Source code in <code>sleap_io/model/skeleton.py</code> <pre><code>def add_symmetry(\n    self, node1: Symmetry | Node | str = None, node2: Node | str = None\n):\n    \"\"\"Add a symmetry relationship to the skeleton.\n\n    Args:\n        node1: The first `Node` or name of the first node.\n        node2: The second `Node` or name of the second node.\n    \"\"\"\n    if type(node1) == Symmetry:\n        if node1 not in self.symmetries:\n            self.symmetries.append(node1)\n            for node in node1.nodes:\n                if node not in self.nodes:\n                    self.add_node(node)\n        return\n\n    if type(node1) == str or type(node1) == Node:\n        try:\n            node1 = self.index(node1)\n        except KeyError:\n            self.add_node(node1)\n            node1 = self.index(node1)\n\n    if type(node2) == str or type(node2) == Node:\n        try:\n            node2 = self.index(node2)\n        except KeyError:\n            self.add_node(node2)\n            node2 = self.index(node2)\n\n    symmetry = Symmetry({self.nodes[node1], self.nodes[node2]})\n    if symmetry not in self.symmetries:\n        self.symmetries.append(symmetry)\n</code></pre>"},{"location":"model/#sleap_io.model.skeleton.Skeleton.index","title":"<code>index(node)</code>","text":"<p>Return the index of a node specified as a <code>Node</code> or string name.</p> Source code in <code>sleap_io/model/skeleton.py</code> <pre><code>def index(self, node: Node | str) -&gt; int:\n    \"\"\"Return the index of a node specified as a `Node` or string name.\"\"\"\n    if type(node) == str:\n        return self.index(self._node_name_map[node])\n    elif type(node) == Node:\n        return self._node_ind_map[node]\n    else:\n        raise IndexError(f\"Invalid indexing argument for skeleton: {node}\")\n</code></pre>"},{"location":"model/#sleap_io.model.skeleton.Symmetry","title":"<code>Symmetry</code>","text":"<p>A relationship between a pair of nodes denoting their left/right pairing.</p> <p>Attributes:</p> Name Type Description <code>nodes</code> <code>set[Node]</code> <p>A set of two <code>Node</code>s.</p> Source code in <code>sleap_io/model/skeleton.py</code> <pre><code>@define\nclass Symmetry:\n    \"\"\"A relationship between a pair of nodes denoting their left/right pairing.\n\n    Attributes:\n        nodes: A set of two `Node`s.\n    \"\"\"\n\n    nodes: set[Node] = field(converter=set, validator=lambda _, __, val: len(val) == 2)\n\n    def __iter__(self):\n        \"\"\"Iterate over the symmetric nodes.\"\"\"\n        return iter(self.nodes)\n\n    def __getitem__(self, idx) -&gt; Node:\n        \"\"\"Return the first node.\"\"\"\n        for i, node in enumerate(self.nodes):\n            if i == idx:\n                return node\n</code></pre>"},{"location":"model/#sleap_io.model.skeleton.Symmetry.__getitem__","title":"<code>__getitem__(idx)</code>","text":"<p>Return the first node.</p> Source code in <code>sleap_io/model/skeleton.py</code> <pre><code>def __getitem__(self, idx) -&gt; Node:\n    \"\"\"Return the first node.\"\"\"\n    for i, node in enumerate(self.nodes):\n        if i == idx:\n            return node\n</code></pre>"},{"location":"model/#sleap_io.model.skeleton.Symmetry.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate over the symmetric nodes.</p> Source code in <code>sleap_io/model/skeleton.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over the symmetric nodes.\"\"\"\n    return iter(self.nodes)\n</code></pre>"},{"location":"model/#sleap_io.model.video","title":"<code>sleap_io.model.video</code>","text":"<p>Data model for videos.</p> <p>The <code>Video</code> class is a SLEAP data structure that stores information regarding a video and its components used in SLEAP.</p>"},{"location":"model/#sleap_io.model.video.Video","title":"<code>Video</code>","text":"<p><code>Video</code> class used by sleap to represent videos and data associated with them.</p> <p>This class is used to store information regarding a video and its components. It is used to store the video's <code>filename</code>, <code>shape</code>, and the video's <code>backend</code>.</p> <p>To create a <code>Video</code> object, use the <code>from_filename</code> method which will select the backend appropriately.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <p>The filename of the video.</p> required <code>backend</code> <p>An object that implements the basic methods for reading and manipulating frames of a specific video type.</p> required <p>See also: VideoBackend</p> Source code in <code>sleap_io/model/video.py</code> <pre><code>@define\nclass Video:\n    \"\"\"`Video` class used by sleap to represent videos and data associated with them.\n\n    This class is used to store information regarding a video and its components.\n    It is used to store the video's `filename`, `shape`, and the video's `backend`.\n\n    To create a `Video` object, use the `from_filename` method which will select the\n    backend appropriately.\n\n    Args:\n        filename: The filename of the video.\n        backend: An object that implements the basic methods for reading and\n            manipulating frames of a specific video type.\n\n    See also: VideoBackend\n    \"\"\"\n\n    filename: str\n    backend: Optional[VideoBackend] = None\n\n    EXTS = MediaVideo.EXTS + HDF5Video.EXTS\n\n    @classmethod\n    def from_filename(\n        cls,\n        filename: str,\n        dataset: Optional[str] = None,\n        grayscale: Optional[str] = None,\n        keep_open: bool = True,\n        **kwargs,\n    ) -&gt; VideoBackend:\n        \"\"\"Create a Video from a filename.\n\n        Args:\n            filename: Path to video file.\n            dataset: Name of dataset in HDF5 file.\n            grayscale: Whether to force grayscale. If None, autodetect on first frame\n                load.\n            keep_open: Whether to keep the video reader open between calls to read\n                frames. If False, will close the reader after each call. If True (the\n                default), it will keep the reader open and cache it for subsequent calls\n                which may enhance the performance of reading multiple frames.\n\n        Returns:\n            Video instance with the appropriate backend instantiated.\n        \"\"\"\n        return cls(\n            filename=filename,\n            backend=VideoBackend.from_filename(\n                filename,\n                dataset=dataset,\n                grayscale=grayscale,\n                keep_open=keep_open,\n                **kwargs,\n            ),\n        )\n\n    @property\n    def shape(self) -&gt; Tuple[int, int, int, int] | None:\n        \"\"\"Return the shape of the video as (num_frames, height, width, channels).\n\n        If the video backend is not set or it cannot determine the shape of the video,\n        this will return None.\n        \"\"\"\n        return self._get_shape()\n\n    def _get_shape(self) -&gt; Tuple[int, int, int, int] | None:\n        \"\"\"Return the shape of the video as (num_frames, height, width, channels).\n\n        This suppresses errors related to querying the backend for the video shape, such\n        as when it has not been set or when the video file is not found.\n        \"\"\"\n        try:\n            return self.backend.shape\n        except:\n            return None\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return the length of the video as the number of frames.\"\"\"\n        shape = self.shape\n        return 0 if shape is None else shape[0]\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Informal string representation (for print or format).\"\"\"\n        dataset = (\n            f\"dataset={self.backend.dataset}, \"\n            if getattr(self.backend, \"dataset\", \"\")\n            else \"\"\n        )\n        return (\n            \"Video(\"\n            f'filename=\"{self.filename}\", '\n            f\"shape={self.shape}, \"\n            f\"{dataset}\"\n            f\"backend={type(self.backend).__name__}\"\n            \")\"\n        )\n\n    def __str__(self) -&gt; str:\n        \"\"\"Informal string representation (for print or format).\"\"\"\n        return self.__repr__()\n\n    def __getitem__(self, inds: int | list[int] | slice) -&gt; np.ndarray:\n        \"\"\"Return the frames of the video at the given indices.\n\n        Args:\n            ind: Index or list of indices of frames to read.\n\n        Returns:\n            Frame or frames as a numpy array of shape `(height, width, channels)` if a\n            scalar index is provided, or `(frames, height, width, channels)` if a list\n            of indices is provided.\n\n        See also: VideoBackend.get_frame, VideoBackend.get_frames\n        \"\"\"\n        if not self.is_open:\n            self.open()\n        return self.backend[inds]\n\n    def exists(self) -&gt; bool:\n        \"\"\"Check if the video file exists.\"\"\"\n        return Path(self.filename).exists()\n\n    @property\n    def is_open(self) -&gt; bool:\n        \"\"\"Check if the video backend is open.\"\"\"\n        return self.exists() and self.backend is not None\n\n    def open(\n        self,\n        dataset: Optional[str] = None,\n        grayscale: Optional[str] = None,\n        keep_open: bool = True,\n    ):\n        \"\"\"Open the video backend for reading.\n\n        Args:\n            dataset: Name of dataset in HDF5 file.\n            grayscale: Whether to force grayscale. If None, autodetect on first frame\n                load.\n            keep_open: Whether to keep the video reader open between calls to read\n                frames. If False, will close the reader after each call. If True (the\n                default), it will keep the reader open and cache it for subsequent calls\n                which may enhance the performance of reading multiple frames.\n\n        Notes:\n            This is useful for opening the video backend to read frames and then closing\n            it after reading all the necessary frames.\n\n            If the backend was already open, it will be closed before opening a new one.\n            Values for the HDF5 dataset and grayscale will be remembered if not\n            specified.\n        \"\"\"\n        if not self.exists():\n            raise FileNotFoundError(f\"Video file not found: {self.filename}\")\n\n        # Try to remember values from previous backend if available and not specified.\n        if self.backend is not None:\n            if dataset is None:\n                dataset = getattr(self.backend, \"dataset\", None)\n            if grayscale is None:\n                grayscale = getattr(self.backend, \"grayscale\", None)\n\n        # Close previous backend if open.\n        self.close()\n\n        # Create new backend.\n        self.backend = VideoBackend.from_filename(\n            self.filename,\n            dataset=dataset,\n            grayscale=grayscale,\n            keep_open=keep_open,\n        )\n\n    def close(self):\n        \"\"\"Close the video backend.\"\"\"\n        if self.backend is not None:\n            del self.backend\n            self.backend = None\n\n    def replace_filename(self, new_filename: str | Path, open: bool = True):\n        \"\"\"Update the filename of the video, optionally opening the backend.\n\n        Args:\n            new_filename: New filename to set for the video.\n            open: If `True` (the default), open the backend with the new filename. If\n                the new filename does not exist, no error is raised.\n        \"\"\"\n        if isinstance(new_filename, Path):\n            new_filename = str(new_filename)\n\n        self.filename = new_filename\n\n        if open:\n            if self.exists():\n                self.open()\n            else:\n                self.close()\n</code></pre>"},{"location":"model/#sleap_io.model.video.Video.is_open","title":"<code>is_open: bool</code>  <code>property</code>","text":"<p>Check if the video backend is open.</p>"},{"location":"model/#sleap_io.model.video.Video.shape","title":"<code>shape: Tuple[int, int, int, int] | None</code>  <code>property</code>","text":"<p>Return the shape of the video as (num_frames, height, width, channels).</p> <p>If the video backend is not set or it cannot determine the shape of the video, this will return None.</p>"},{"location":"model/#sleap_io.model.video.Video.__getitem__","title":"<code>__getitem__(inds)</code>","text":"<p>Return the frames of the video at the given indices.</p> <p>Parameters:</p> Name Type Description Default <code>ind</code> <p>Index or list of indices of frames to read.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Frame or frames as a numpy array of shape <code>(height, width, channels)</code> if a</p> <code>ndarray</code> <p>scalar index is provided, or <code>(frames, height, width, channels)</code> if a list</p> <code>ndarray</code> <p>of indices is provided.</p> <p>See also: VideoBackend.get_frame, VideoBackend.get_frames</p> Source code in <code>sleap_io/model/video.py</code> <pre><code>def __getitem__(self, inds: int | list[int] | slice) -&gt; np.ndarray:\n    \"\"\"Return the frames of the video at the given indices.\n\n    Args:\n        ind: Index or list of indices of frames to read.\n\n    Returns:\n        Frame or frames as a numpy array of shape `(height, width, channels)` if a\n        scalar index is provided, or `(frames, height, width, channels)` if a list\n        of indices is provided.\n\n    See also: VideoBackend.get_frame, VideoBackend.get_frames\n    \"\"\"\n    if not self.is_open:\n        self.open()\n    return self.backend[inds]\n</code></pre>"},{"location":"model/#sleap_io.model.video.Video.__len__","title":"<code>__len__()</code>","text":"<p>Return the length of the video as the number of frames.</p> Source code in <code>sleap_io/model/video.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return the length of the video as the number of frames.\"\"\"\n    shape = self.shape\n    return 0 if shape is None else shape[0]\n</code></pre>"},{"location":"model/#sleap_io.model.video.Video.__repr__","title":"<code>__repr__()</code>","text":"<p>Informal string representation (for print or format).</p> Source code in <code>sleap_io/model/video.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Informal string representation (for print or format).\"\"\"\n    dataset = (\n        f\"dataset={self.backend.dataset}, \"\n        if getattr(self.backend, \"dataset\", \"\")\n        else \"\"\n    )\n    return (\n        \"Video(\"\n        f'filename=\"{self.filename}\", '\n        f\"shape={self.shape}, \"\n        f\"{dataset}\"\n        f\"backend={type(self.backend).__name__}\"\n        \")\"\n    )\n</code></pre>"},{"location":"model/#sleap_io.model.video.Video.__str__","title":"<code>__str__()</code>","text":"<p>Informal string representation (for print or format).</p> Source code in <code>sleap_io/model/video.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Informal string representation (for print or format).\"\"\"\n    return self.__repr__()\n</code></pre>"},{"location":"model/#sleap_io.model.video.Video.close","title":"<code>close()</code>","text":"<p>Close the video backend.</p> Source code in <code>sleap_io/model/video.py</code> <pre><code>def close(self):\n    \"\"\"Close the video backend.\"\"\"\n    if self.backend is not None:\n        del self.backend\n        self.backend = None\n</code></pre>"},{"location":"model/#sleap_io.model.video.Video.exists","title":"<code>exists()</code>","text":"<p>Check if the video file exists.</p> Source code in <code>sleap_io/model/video.py</code> <pre><code>def exists(self) -&gt; bool:\n    \"\"\"Check if the video file exists.\"\"\"\n    return Path(self.filename).exists()\n</code></pre>"},{"location":"model/#sleap_io.model.video.Video.from_filename","title":"<code>from_filename(filename, dataset=None, grayscale=None, keep_open=True, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create a Video from a filename.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to video file.</p> required <code>dataset</code> <code>Optional[str]</code> <p>Name of dataset in HDF5 file.</p> <code>None</code> <code>grayscale</code> <code>Optional[str]</code> <p>Whether to force grayscale. If None, autodetect on first frame load.</p> <code>None</code> <code>keep_open</code> <code>bool</code> <p>Whether to keep the video reader open between calls to read frames. If False, will close the reader after each call. If True (the default), it will keep the reader open and cache it for subsequent calls which may enhance the performance of reading multiple frames.</p> <code>True</code> <p>Returns:</p> Type Description <code>VideoBackend</code> <p>Video instance with the appropriate backend instantiated.</p> Source code in <code>sleap_io/model/video.py</code> <pre><code>@classmethod\ndef from_filename(\n    cls,\n    filename: str,\n    dataset: Optional[str] = None,\n    grayscale: Optional[str] = None,\n    keep_open: bool = True,\n    **kwargs,\n) -&gt; VideoBackend:\n    \"\"\"Create a Video from a filename.\n\n    Args:\n        filename: Path to video file.\n        dataset: Name of dataset in HDF5 file.\n        grayscale: Whether to force grayscale. If None, autodetect on first frame\n            load.\n        keep_open: Whether to keep the video reader open between calls to read\n            frames. If False, will close the reader after each call. If True (the\n            default), it will keep the reader open and cache it for subsequent calls\n            which may enhance the performance of reading multiple frames.\n\n    Returns:\n        Video instance with the appropriate backend instantiated.\n    \"\"\"\n    return cls(\n        filename=filename,\n        backend=VideoBackend.from_filename(\n            filename,\n            dataset=dataset,\n            grayscale=grayscale,\n            keep_open=keep_open,\n            **kwargs,\n        ),\n    )\n</code></pre>"},{"location":"model/#sleap_io.model.video.Video.open","title":"<code>open(dataset=None, grayscale=None, keep_open=True)</code>","text":"<p>Open the video backend for reading.</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>Optional[str]</code> <p>Name of dataset in HDF5 file.</p> <code>None</code> <code>grayscale</code> <code>Optional[str]</code> <p>Whether to force grayscale. If None, autodetect on first frame load.</p> <code>None</code> <code>keep_open</code> <code>bool</code> <p>Whether to keep the video reader open between calls to read frames. If False, will close the reader after each call. If True (the default), it will keep the reader open and cache it for subsequent calls which may enhance the performance of reading multiple frames.</p> <code>True</code> Notes <p>This is useful for opening the video backend to read frames and then closing it after reading all the necessary frames.</p> <p>If the backend was already open, it will be closed before opening a new one. Values for the HDF5 dataset and grayscale will be remembered if not specified.</p> Source code in <code>sleap_io/model/video.py</code> <pre><code>def open(\n    self,\n    dataset: Optional[str] = None,\n    grayscale: Optional[str] = None,\n    keep_open: bool = True,\n):\n    \"\"\"Open the video backend for reading.\n\n    Args:\n        dataset: Name of dataset in HDF5 file.\n        grayscale: Whether to force grayscale. If None, autodetect on first frame\n            load.\n        keep_open: Whether to keep the video reader open between calls to read\n            frames. If False, will close the reader after each call. If True (the\n            default), it will keep the reader open and cache it for subsequent calls\n            which may enhance the performance of reading multiple frames.\n\n    Notes:\n        This is useful for opening the video backend to read frames and then closing\n        it after reading all the necessary frames.\n\n        If the backend was already open, it will be closed before opening a new one.\n        Values for the HDF5 dataset and grayscale will be remembered if not\n        specified.\n    \"\"\"\n    if not self.exists():\n        raise FileNotFoundError(f\"Video file not found: {self.filename}\")\n\n    # Try to remember values from previous backend if available and not specified.\n    if self.backend is not None:\n        if dataset is None:\n            dataset = getattr(self.backend, \"dataset\", None)\n        if grayscale is None:\n            grayscale = getattr(self.backend, \"grayscale\", None)\n\n    # Close previous backend if open.\n    self.close()\n\n    # Create new backend.\n    self.backend = VideoBackend.from_filename(\n        self.filename,\n        dataset=dataset,\n        grayscale=grayscale,\n        keep_open=keep_open,\n    )\n</code></pre>"},{"location":"model/#sleap_io.model.video.Video.replace_filename","title":"<code>replace_filename(new_filename, open=True)</code>","text":"<p>Update the filename of the video, optionally opening the backend.</p> <p>Parameters:</p> Name Type Description Default <code>new_filename</code> <code>str | Path</code> <p>New filename to set for the video.</p> required <code>open</code> <code>bool</code> <p>If <code>True</code> (the default), open the backend with the new filename. If the new filename does not exist, no error is raised.</p> <code>True</code> Source code in <code>sleap_io/model/video.py</code> <pre><code>def replace_filename(self, new_filename: str | Path, open: bool = True):\n    \"\"\"Update the filename of the video, optionally opening the backend.\n\n    Args:\n        new_filename: New filename to set for the video.\n        open: If `True` (the default), open the backend with the new filename. If\n            the new filename does not exist, no error is raised.\n    \"\"\"\n    if isinstance(new_filename, Path):\n        new_filename = str(new_filename)\n\n    self.filename = new_filename\n\n    if open:\n        if self.exists():\n            self.open()\n        else:\n            self.close()\n</code></pre>"}]}