{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"sleap-io documentation","text":""},{"location":"model/","title":"Data model","text":"<p>Data structure for the labels, a top-level container for pose data.</p> <p><code>Label</code>s contain <code>LabeledFrame</code>s, which in turn contain <code>Instance</code>s, which contain <code>Point</code>s.</p> <p>This structure also maintains metadata that is common across all child objects such as <code>Track</code>s, <code>Video</code>s, <code>Skeleton</code>s and others.</p> <p>It is intended to be the entrypoint for deserialization and main container that should be used for serialization. It is designed to support both labeled data (used for training models) and predictions (inference results).</p>"},{"location":"model/#sleap_io.model.labels.Labels","title":"<code>Labels</code>","text":"<p>Pose data for a set of videos that have user labels and/or predictions.</p> <p>Attributes:</p> Name Type Description <code>labeled_frames</code> <code>list[LabeledFrame]</code> <p>A list of <code>LabeledFrame</code>s that are associated with this dataset.</p> <code>videos</code> <code>list[Video]</code> <p>A list of <code>Video</code>s that are associated with this dataset. Videos do not need to have corresponding <code>LabeledFrame</code>s if they do not have any labels or predictions yet.</p> <code>skeletons</code> <code>list[Skeleton]</code> <p>A list of <code>Skeleton</code>s that are associated with this dataset. This should generally only contain a single skeleton.</p> <code>tracks</code> <code>list[Track]</code> <p>A list of <code>Track</code>s that are associated with this dataset.</p> <code>provenance</code> <code>dict[str, Any]</code> <p>Dictionary of arbitrary metadata providing additional information about where the dataset came from.</p> Notes <p><code>Video</code>s in contain <code>LabeledFrame</code>s, and <code>Skeleton</code>s and <code>Track</code>s in contained <code>Instance</code>s are added to the respective lists automatically.</p> Source code in <code>sleap_io/model/labels.py</code> <pre><code>@define\nclass Labels:\n    \"\"\"Pose data for a set of videos that have user labels and/or predictions.\n\n    Attributes:\n        labeled_frames: A list of `LabeledFrame`s that are associated with this dataset.\n        videos: A list of `Video`s that are associated with this dataset. Videos do not\n            need to have corresponding `LabeledFrame`s if they do not have any\n            labels or predictions yet.\n        skeletons: A list of `Skeleton`s that are associated with this dataset. This\n            should generally only contain a single skeleton.\n        tracks: A list of `Track`s that are associated with this dataset.\n        provenance: Dictionary of arbitrary metadata providing additional information\n            about where the dataset came from.\n\n    Notes:\n        `Video`s in contain `LabeledFrame`s, and `Skeleton`s and `Track`s in contained\n        `Instance`s are added to the respective lists automatically.\n    \"\"\"\n\n    labeled_frames: list[LabeledFrame] = field(factory=list)\n    videos: list[Video] = field(factory=list)\n    skeletons: list[Skeleton] = field(factory=list)\n    tracks: list[Track] = field(factory=list)\n    provenance: dict[str, Any] = field(factory=dict)\n\n    def __attrs_post_init__(self):\n        \"\"\"Append videos, skeletons, and tracks seen in `labeled_frames` to `Labels`.\"\"\"\n        for lf in self.labeled_frames:\n            if lf.video not in self.videos:\n                self.videos.append(lf.video)\n\n            for inst in lf:\n                if inst.skeleton not in self.skeletons:\n                    self.skeletons.append(inst.skeleton)\n\n                if inst.track is not None and inst.track not in self.tracks:\n                    self.tracks.append(inst.track)\n\n    def __getitem__(self, key: int) -&gt; list[LabeledFrame] | LabeledFrame:\n        \"\"\"Return one or more labeled frames based on indexing criteria.\"\"\"\n        if type(key) == int:\n            return self.labeled_frames[key]\n        elif type(key) == slice:\n            return [self.labeled_frames[i] for i in range(*key.indices(len(self)))]\n        elif type(key) == list:\n            return [self.labeled_frames[i] for i in key]\n        elif isinstance(key, np.ndarray):\n            return [self.labeled_frames[i] for i in key.tolist()]\n        elif type(key) == tuple and len(key) == 2:\n            video, frame_idx = key\n            res = self.find(video, frame_idx)\n            if len(res) == 1:\n                return res[0]\n            elif len(res) == 0:\n                raise IndexError(\n                    f\"No labeled frames found for video {video} and \"\n                    f\"frame index {frame_idx}.\"\n                )\n        elif type(key) == Video:\n            res = self.find(key)\n            if len(res) == 0:\n                raise IndexError(f\"No labeled frames found for video {key}.\")\n            return res\n        else:\n            raise IndexError(f\"Invalid indexing argument for labels: {key}\")\n\n    def __iter__(self):\n        \"\"\"Iterate over `labeled_frames` list when calling iter method on `Labels`.\"\"\"\n        return iter(self.labeled_frames)\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return number of labeled frames.\"\"\"\n        return len(self.labeled_frames)\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a readable representation of the labels.\"\"\"\n        return (\n            \"Labels(\"\n            f\"labeled_frames={len(self.labeled_frames)}, \"\n            f\"videos={len(self.videos)}, \"\n            f\"skeletons={len(self.skeletons)}, \"\n            f\"tracks={len(self.tracks)}\"\n            \")\"\n        )\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a readable representation of the labels.\"\"\"\n        return self.__repr__()\n\n    def numpy(\n        self,\n        video: Optional[Union[Video, int]] = None,\n        all_frames: bool = True,\n        untracked: bool = False,\n        return_confidence: bool = False,\n    ) -&gt; np.ndarray:\n        \"\"\"Construct a numpy array from instance points.\n\n        Args:\n            video: Video or video index to convert to numpy arrays. If `None` (the\n                default), uses the first video.\n            untracked: If `False` (the default), include only instances that have a\n                track assignment. If `True`, includes all instances in each frame in\n                arbitrary order.\n            return_confidence: If `False` (the default), only return points of nodes. If\n                `True`, return the points and scores of nodes.\n\n        Returns:\n            An array of tracks of shape `(n_frames, n_tracks, n_nodes, 2)` if\n            `return_confidence` is `False`. Otherwise returned shape is\n            `(n_frames, n_tracks, n_nodes, 3)` if `return_confidence` is `True`.\n\n            Missing data will be replaced with `np.nan`.\n\n            If this is a single instance project, a track does not need to be assigned.\n\n            Only predicted instances (NOT user instances) will be returned.\n\n        Notes:\n            This method assumes that instances have tracks assigned and is intended to\n            function primarily for single-video prediction results.\n        \"\"\"\n        # Get labeled frames for specified video.\n        if video is None:\n            video = 0\n        if type(video) == int:\n            video = self.videos[video]\n        lfs = [lf for lf in self.labeled_frames if lf.video == video]\n\n        # Figure out frame index range.\n        first_frame, last_frame = 0, 0\n        for lf in lfs:\n            first_frame = min(first_frame, lf.frame_idx)\n            last_frame = max(last_frame, lf.frame_idx)\n\n        # Figure out the number of tracks based on number of instances in each frame.\n        # First, let's check the max number of predicted instances (regardless of\n        # whether they're tracked.\n        n_preds = 0\n        for lf in lfs:\n            n_pred_instances = len(lf.predicted_instances)\n            n_preds = max(n_preds, n_pred_instances)\n\n        # Case 1: We don't care about order because there's only 1 instance per frame,\n        # or we're considering untracked instances.\n        untracked = untracked or n_preds == 1\n        if untracked:\n            n_tracks = n_preds\n        else:\n            # Case 2: We're considering only tracked instances.\n            n_tracks = len(self.tracks)\n\n        n_frames = int(last_frame - first_frame + 1)\n        skeleton = self.skeletons[-1]  # Assume project only uses last skeleton\n        n_nodes = len(skeleton.nodes)\n\n        if return_confidence:\n            tracks = np.full((n_frames, n_tracks, n_nodes, 3), np.nan, dtype=\"float32\")\n        else:\n            tracks = np.full((n_frames, n_tracks, n_nodes, 2), np.nan, dtype=\"float32\")\n        for lf in lfs:\n            i = int(lf.frame_idx - first_frame)\n            if untracked:\n                for j, inst in enumerate(lf.predicted_instances):\n                    tracks[i, j] = inst.numpy(scores=return_confidence)\n            else:\n                tracked_instances = [\n                    inst\n                    for inst in lf.instances\n                    if type(inst) == PredictedInstance and inst.track is not None\n                ]\n                for inst in tracked_instances:\n                    j = self.tracks.index(inst.track)  # type: ignore[arg-type]\n                    tracks[i, j] = inst.numpy(scores=return_confidence)\n\n        return tracks\n\n    @property\n    def video(self) -&gt; Video:\n        \"\"\"Return the video if there is only a single video in the labels.\"\"\"\n        if len(self.videos) == 0:\n            raise ValueError(\"There are no videos in the labels.\")\n        elif len(self.videos) == 1:\n            return self.videos[0]\n        else:\n            raise ValueError(\n                \"Labels.video can only be used when there is only a single video saved \"\n                \"in the labels. Use Labels.videos instead.\"\n            )\n\n    @property\n    def skeleton(self) -&gt; Skeleton:\n        \"\"\"Return the skeleton if there is only a single skeleton in the labels.\"\"\"\n        if len(self.skeletons) == 0:\n            raise ValueError(\"There are no skeletons in the labels.\")\n        elif len(self.skeletons) == 1:\n            return self.skeletons[0]\n        else:\n            raise ValueError(\n                \"Labels.skeleton can only be used when there is only a single skeleton \"\n                \"saved in the labels. Use Labels.skeletons instead.\"\n            )\n\n    def find(\n        self,\n        video: Video,\n        frame_idx: int | list[int] | None = None,\n        return_new: bool = False,\n    ) -&gt; list[LabeledFrame]:\n        \"\"\"Search for labeled frames given video and/or frame index.\n\n        Args:\n            video: A `Video` that is associated with the project.\n            frame_idx: The frame index (or indices) which we want to find in the video.\n                If a range is specified, we'll return all frames with indices in that\n                range. If not specific, then we'll return all labeled frames for video.\n            return_new: Whether to return singleton of new and empty `LabeledFrame` if\n                none are found in project.\n\n        Returns:\n            List of `LabeledFrame` objects that match the criteria.\n\n            The list will be empty if no matches found, unless return_new is True,\n            in which case it contains new (empty) `LabeledFrame` objects with `video`\n            and `frame_index` set.\n        \"\"\"\n        results = []\n\n        if frame_idx is None:\n            for lf in self.labeled_frames:\n                if lf.video == video:\n                    results.append(lf)\n            return results\n\n        if np.isscalar(frame_idx):\n            frame_idx = np.array(frame_idx).reshape(-1)\n\n        for frame_ind in frame_idx:\n            result = None\n            for lf in self.labeled_frames:\n                if lf.video == video and lf.frame_idx == frame_ind:\n                    result = lf\n                    results.append(result)\n                    break\n            if result is None and return_new:\n                results.append(LabeledFrame(video=video, frame_idx=frame_ind))\n\n        return results\n\n    def save(self, filename: str, format: Optional[str] = None, **kwargs):\n        \"\"\"Save labels to file in specified format.\n\n        Args:\n            filename: Path to save labels to.\n            format: The format to save the labels in. If `None`, the format will be\n                inferred from the file extension. Available formats are \"slp\", \"nwb\",\n                \"labelstudio\", and \"jabs\".\n        \"\"\"\n        from sleap_io import save_file\n\n        save_file(self, filename, format=format, **kwargs)\n\n    def clean(\n        self,\n        frames: bool = True,\n        empty_instances: bool = False,\n        skeletons: bool = True,\n        tracks: bool = True,\n        videos: bool = False,\n    ):\n        \"\"\"Remove empty frames, unused skeletons, tracks and videos.\n\n        Args:\n            frames: If `True` (the default), remove empty frames.\n            empty_instances: If `True` (NOT default), remove instances that have no\n                visible points.\n            skeletons: If `True` (the default), remove unused skeletons.\n            tracks: If `True` (the default), remove unused tracks.\n            videos: If `True` (NOT default), remove videos that have no labeled frames.\n        \"\"\"\n        used_skeletons = []\n        used_tracks = []\n        used_videos = []\n        kept_frames = []\n        for lf in self.labeled_frames:\n\n            if empty_instances:\n                lf.remove_empty_instances()\n\n            if frames and len(lf) == 0:\n                continue\n\n            if videos and lf.video not in used_videos:\n                used_videos.append(lf.video)\n\n            if skeletons or tracks:\n                for inst in lf:\n                    if skeletons and inst.skeleton not in used_skeletons:\n                        used_skeletons.append(inst.skeleton)\n                    if (\n                        tracks\n                        and inst.track is not None\n                        and inst.track not in used_tracks\n                    ):\n                        used_tracks.append(inst.track)\n\n            if frames:\n                kept_frames.append(lf)\n\n        if videos:\n            self.videos = [video for video in self.videos if video in used_videos]\n\n        if skeletons:\n            self.skeletons = [\n                skeleton for skeleton in self.skeletons if skeleton in used_skeletons\n            ]\n\n        if tracks:\n            self.tracks = [track for track in self.tracks if track in used_tracks]\n\n        if frames:\n            self.labeled_frames = kept_frames\n\n    def remove_predictions(self, clean: bool = True):\n        \"\"\"Remove all predicted instances from the labels.\n\n        Args:\n            clean: If `True` (the default), also remove any empty frames and unused\n                tracks and skeletons. It does NOT remove videos that have no labeled\n                frames or instances with no visible points.\n\n        See also: `Labels.clean`\n        \"\"\"\n        for lf in self.labeled_frames:\n            lf.remove_predictions()\n\n        if clean:\n            self.clean(\n                frames=True,\n                empty_instances=False,\n                skeletons=True,\n                tracks=True,\n                videos=False,\n            )\n</code></pre>"},{"location":"model/#sleap_io.model.labels.Labels.skeleton","title":"<code>skeleton: Skeleton</code>  <code>property</code>","text":"<p>Return the skeleton if there is only a single skeleton in the labels.</p>"},{"location":"model/#sleap_io.model.labels.Labels.video","title":"<code>video: Video</code>  <code>property</code>","text":"<p>Return the video if there is only a single video in the labels.</p>"},{"location":"model/#sleap_io.model.labels.Labels.__attrs_post_init__","title":"<code>__attrs_post_init__()</code>","text":"<p>Append videos, skeletons, and tracks seen in <code>labeled_frames</code> to <code>Labels</code>.</p> Source code in <code>sleap_io/model/labels.py</code> <pre><code>def __attrs_post_init__(self):\n    \"\"\"Append videos, skeletons, and tracks seen in `labeled_frames` to `Labels`.\"\"\"\n    for lf in self.labeled_frames:\n        if lf.video not in self.videos:\n            self.videos.append(lf.video)\n\n        for inst in lf:\n            if inst.skeleton not in self.skeletons:\n                self.skeletons.append(inst.skeleton)\n\n            if inst.track is not None and inst.track not in self.tracks:\n                self.tracks.append(inst.track)\n</code></pre>"},{"location":"model/#sleap_io.model.labels.Labels.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Return one or more labeled frames based on indexing criteria.</p> Source code in <code>sleap_io/model/labels.py</code> <pre><code>def __getitem__(self, key: int) -&gt; list[LabeledFrame] | LabeledFrame:\n    \"\"\"Return one or more labeled frames based on indexing criteria.\"\"\"\n    if type(key) == int:\n        return self.labeled_frames[key]\n    elif type(key) == slice:\n        return [self.labeled_frames[i] for i in range(*key.indices(len(self)))]\n    elif type(key) == list:\n        return [self.labeled_frames[i] for i in key]\n    elif isinstance(key, np.ndarray):\n        return [self.labeled_frames[i] for i in key.tolist()]\n    elif type(key) == tuple and len(key) == 2:\n        video, frame_idx = key\n        res = self.find(video, frame_idx)\n        if len(res) == 1:\n            return res[0]\n        elif len(res) == 0:\n            raise IndexError(\n                f\"No labeled frames found for video {video} and \"\n                f\"frame index {frame_idx}.\"\n            )\n    elif type(key) == Video:\n        res = self.find(key)\n        if len(res) == 0:\n            raise IndexError(f\"No labeled frames found for video {key}.\")\n        return res\n    else:\n        raise IndexError(f\"Invalid indexing argument for labels: {key}\")\n</code></pre>"},{"location":"model/#sleap_io.model.labels.Labels.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate over <code>labeled_frames</code> list when calling iter method on <code>Labels</code>.</p> Source code in <code>sleap_io/model/labels.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over `labeled_frames` list when calling iter method on `Labels`.\"\"\"\n    return iter(self.labeled_frames)\n</code></pre>"},{"location":"model/#sleap_io.model.labels.Labels.__len__","title":"<code>__len__()</code>","text":"<p>Return number of labeled frames.</p> Source code in <code>sleap_io/model/labels.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return number of labeled frames.\"\"\"\n    return len(self.labeled_frames)\n</code></pre>"},{"location":"model/#sleap_io.model.labels.Labels.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a readable representation of the labels.</p> Source code in <code>sleap_io/model/labels.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a readable representation of the labels.\"\"\"\n    return (\n        \"Labels(\"\n        f\"labeled_frames={len(self.labeled_frames)}, \"\n        f\"videos={len(self.videos)}, \"\n        f\"skeletons={len(self.skeletons)}, \"\n        f\"tracks={len(self.tracks)}\"\n        \")\"\n    )\n</code></pre>"},{"location":"model/#sleap_io.model.labels.Labels.__str__","title":"<code>__str__()</code>","text":"<p>Return a readable representation of the labels.</p> Source code in <code>sleap_io/model/labels.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a readable representation of the labels.\"\"\"\n    return self.__repr__()\n</code></pre>"},{"location":"model/#sleap_io.model.labels.Labels.clean","title":"<code>clean(frames=True, empty_instances=False, skeletons=True, tracks=True, videos=False)</code>","text":"<p>Remove empty frames, unused skeletons, tracks and videos.</p> <p>Parameters:</p> Name Type Description Default <code>frames</code> <code>bool</code> <p>If <code>True</code> (the default), remove empty frames.</p> <code>True</code> <code>empty_instances</code> <code>bool</code> <p>If <code>True</code> (NOT default), remove instances that have no visible points.</p> <code>False</code> <code>skeletons</code> <code>bool</code> <p>If <code>True</code> (the default), remove unused skeletons.</p> <code>True</code> <code>tracks</code> <code>bool</code> <p>If <code>True</code> (the default), remove unused tracks.</p> <code>True</code> <code>videos</code> <code>bool</code> <p>If <code>True</code> (NOT default), remove videos that have no labeled frames.</p> <code>False</code> Source code in <code>sleap_io/model/labels.py</code> <pre><code>def clean(\n    self,\n    frames: bool = True,\n    empty_instances: bool = False,\n    skeletons: bool = True,\n    tracks: bool = True,\n    videos: bool = False,\n):\n    \"\"\"Remove empty frames, unused skeletons, tracks and videos.\n\n    Args:\n        frames: If `True` (the default), remove empty frames.\n        empty_instances: If `True` (NOT default), remove instances that have no\n            visible points.\n        skeletons: If `True` (the default), remove unused skeletons.\n        tracks: If `True` (the default), remove unused tracks.\n        videos: If `True` (NOT default), remove videos that have no labeled frames.\n    \"\"\"\n    used_skeletons = []\n    used_tracks = []\n    used_videos = []\n    kept_frames = []\n    for lf in self.labeled_frames:\n\n        if empty_instances:\n            lf.remove_empty_instances()\n\n        if frames and len(lf) == 0:\n            continue\n\n        if videos and lf.video not in used_videos:\n            used_videos.append(lf.video)\n\n        if skeletons or tracks:\n            for inst in lf:\n                if skeletons and inst.skeleton not in used_skeletons:\n                    used_skeletons.append(inst.skeleton)\n                if (\n                    tracks\n                    and inst.track is not None\n                    and inst.track not in used_tracks\n                ):\n                    used_tracks.append(inst.track)\n\n        if frames:\n            kept_frames.append(lf)\n\n    if videos:\n        self.videos = [video for video in self.videos if video in used_videos]\n\n    if skeletons:\n        self.skeletons = [\n            skeleton for skeleton in self.skeletons if skeleton in used_skeletons\n        ]\n\n    if tracks:\n        self.tracks = [track for track in self.tracks if track in used_tracks]\n\n    if frames:\n        self.labeled_frames = kept_frames\n</code></pre>"},{"location":"model/#sleap_io.model.labels.Labels.find","title":"<code>find(video, frame_idx=None, return_new=False)</code>","text":"<p>Search for labeled frames given video and/or frame index.</p> <p>Parameters:</p> Name Type Description Default <code>video</code> <code>Video</code> <p>A <code>Video</code> that is associated with the project.</p> required <code>frame_idx</code> <code>int | list[int] | None</code> <p>The frame index (or indices) which we want to find in the video. If a range is specified, we'll return all frames with indices in that range. If not specific, then we'll return all labeled frames for video.</p> <code>None</code> <code>return_new</code> <code>bool</code> <p>Whether to return singleton of new and empty <code>LabeledFrame</code> if none are found in project.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[LabeledFrame]</code> <p>List of <code>LabeledFrame</code> objects that match the criteria.</p> <code>list[LabeledFrame]</code> <p>The list will be empty if no matches found, unless return_new is True,</p> <code>list[LabeledFrame]</code> <p>in which case it contains new (empty) <code>LabeledFrame</code> objects with <code>video</code></p> <code>list[LabeledFrame]</code> <p>and <code>frame_index</code> set.</p> Source code in <code>sleap_io/model/labels.py</code> <pre><code>def find(\n    self,\n    video: Video,\n    frame_idx: int | list[int] | None = None,\n    return_new: bool = False,\n) -&gt; list[LabeledFrame]:\n    \"\"\"Search for labeled frames given video and/or frame index.\n\n    Args:\n        video: A `Video` that is associated with the project.\n        frame_idx: The frame index (or indices) which we want to find in the video.\n            If a range is specified, we'll return all frames with indices in that\n            range. If not specific, then we'll return all labeled frames for video.\n        return_new: Whether to return singleton of new and empty `LabeledFrame` if\n            none are found in project.\n\n    Returns:\n        List of `LabeledFrame` objects that match the criteria.\n\n        The list will be empty if no matches found, unless return_new is True,\n        in which case it contains new (empty) `LabeledFrame` objects with `video`\n        and `frame_index` set.\n    \"\"\"\n    results = []\n\n    if frame_idx is None:\n        for lf in self.labeled_frames:\n            if lf.video == video:\n                results.append(lf)\n        return results\n\n    if np.isscalar(frame_idx):\n        frame_idx = np.array(frame_idx).reshape(-1)\n\n    for frame_ind in frame_idx:\n        result = None\n        for lf in self.labeled_frames:\n            if lf.video == video and lf.frame_idx == frame_ind:\n                result = lf\n                results.append(result)\n                break\n        if result is None and return_new:\n            results.append(LabeledFrame(video=video, frame_idx=frame_ind))\n\n    return results\n</code></pre>"},{"location":"model/#sleap_io.model.labels.Labels.numpy","title":"<code>numpy(video=None, all_frames=True, untracked=False, return_confidence=False)</code>","text":"<p>Construct a numpy array from instance points.</p> <p>Parameters:</p> Name Type Description Default <code>video</code> <code>Optional[Union[Video, int]]</code> <p>Video or video index to convert to numpy arrays. If <code>None</code> (the default), uses the first video.</p> <code>None</code> <code>untracked</code> <code>bool</code> <p>If <code>False</code> (the default), include only instances that have a track assignment. If <code>True</code>, includes all instances in each frame in arbitrary order.</p> <code>False</code> <code>return_confidence</code> <code>bool</code> <p>If <code>False</code> (the default), only return points of nodes. If <code>True</code>, return the points and scores of nodes.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>An array of tracks of shape <code>(n_frames, n_tracks, n_nodes, 2)</code> if</p> <code>ndarray</code> <p><code>return_confidence</code> is <code>False</code>. Otherwise returned shape is</p> <code>ndarray</code> <p><code>(n_frames, n_tracks, n_nodes, 3)</code> if <code>return_confidence</code> is <code>True</code>.</p> <code>ndarray</code> <p>Missing data will be replaced with <code>np.nan</code>.</p> <code>ndarray</code> <p>If this is a single instance project, a track does not need to be assigned.</p> <code>ndarray</code> <p>Only predicted instances (NOT user instances) will be returned.</p> Notes <p>This method assumes that instances have tracks assigned and is intended to function primarily for single-video prediction results.</p> Source code in <code>sleap_io/model/labels.py</code> <pre><code>def numpy(\n    self,\n    video: Optional[Union[Video, int]] = None,\n    all_frames: bool = True,\n    untracked: bool = False,\n    return_confidence: bool = False,\n) -&gt; np.ndarray:\n    \"\"\"Construct a numpy array from instance points.\n\n    Args:\n        video: Video or video index to convert to numpy arrays. If `None` (the\n            default), uses the first video.\n        untracked: If `False` (the default), include only instances that have a\n            track assignment. If `True`, includes all instances in each frame in\n            arbitrary order.\n        return_confidence: If `False` (the default), only return points of nodes. If\n            `True`, return the points and scores of nodes.\n\n    Returns:\n        An array of tracks of shape `(n_frames, n_tracks, n_nodes, 2)` if\n        `return_confidence` is `False`. Otherwise returned shape is\n        `(n_frames, n_tracks, n_nodes, 3)` if `return_confidence` is `True`.\n\n        Missing data will be replaced with `np.nan`.\n\n        If this is a single instance project, a track does not need to be assigned.\n\n        Only predicted instances (NOT user instances) will be returned.\n\n    Notes:\n        This method assumes that instances have tracks assigned and is intended to\n        function primarily for single-video prediction results.\n    \"\"\"\n    # Get labeled frames for specified video.\n    if video is None:\n        video = 0\n    if type(video) == int:\n        video = self.videos[video]\n    lfs = [lf for lf in self.labeled_frames if lf.video == video]\n\n    # Figure out frame index range.\n    first_frame, last_frame = 0, 0\n    for lf in lfs:\n        first_frame = min(first_frame, lf.frame_idx)\n        last_frame = max(last_frame, lf.frame_idx)\n\n    # Figure out the number of tracks based on number of instances in each frame.\n    # First, let's check the max number of predicted instances (regardless of\n    # whether they're tracked.\n    n_preds = 0\n    for lf in lfs:\n        n_pred_instances = len(lf.predicted_instances)\n        n_preds = max(n_preds, n_pred_instances)\n\n    # Case 1: We don't care about order because there's only 1 instance per frame,\n    # or we're considering untracked instances.\n    untracked = untracked or n_preds == 1\n    if untracked:\n        n_tracks = n_preds\n    else:\n        # Case 2: We're considering only tracked instances.\n        n_tracks = len(self.tracks)\n\n    n_frames = int(last_frame - first_frame + 1)\n    skeleton = self.skeletons[-1]  # Assume project only uses last skeleton\n    n_nodes = len(skeleton.nodes)\n\n    if return_confidence:\n        tracks = np.full((n_frames, n_tracks, n_nodes, 3), np.nan, dtype=\"float32\")\n    else:\n        tracks = np.full((n_frames, n_tracks, n_nodes, 2), np.nan, dtype=\"float32\")\n    for lf in lfs:\n        i = int(lf.frame_idx - first_frame)\n        if untracked:\n            for j, inst in enumerate(lf.predicted_instances):\n                tracks[i, j] = inst.numpy(scores=return_confidence)\n        else:\n            tracked_instances = [\n                inst\n                for inst in lf.instances\n                if type(inst) == PredictedInstance and inst.track is not None\n            ]\n            for inst in tracked_instances:\n                j = self.tracks.index(inst.track)  # type: ignore[arg-type]\n                tracks[i, j] = inst.numpy(scores=return_confidence)\n\n    return tracks\n</code></pre>"},{"location":"model/#sleap_io.model.labels.Labels.remove_predictions","title":"<code>remove_predictions(clean=True)</code>","text":"<p>Remove all predicted instances from the labels.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If <code>True</code> (the default), also remove any empty frames and unused tracks and skeletons. It does NOT remove videos that have no labeled frames or instances with no visible points.</p> <code>True</code> <p>See also: <code>Labels.clean</code></p> Source code in <code>sleap_io/model/labels.py</code> <pre><code>def remove_predictions(self, clean: bool = True):\n    \"\"\"Remove all predicted instances from the labels.\n\n    Args:\n        clean: If `True` (the default), also remove any empty frames and unused\n            tracks and skeletons. It does NOT remove videos that have no labeled\n            frames or instances with no visible points.\n\n    See also: `Labels.clean`\n    \"\"\"\n    for lf in self.labeled_frames:\n        lf.remove_predictions()\n\n    if clean:\n        self.clean(\n            frames=True,\n            empty_instances=False,\n            skeletons=True,\n            tracks=True,\n            videos=False,\n        )\n</code></pre>"},{"location":"model/#sleap_io.model.labels.Labels.save","title":"<code>save(filename, format=None, **kwargs)</code>","text":"<p>Save labels to file in specified format.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to save labels to.</p> required <code>format</code> <code>Optional[str]</code> <p>The format to save the labels in. If <code>None</code>, the format will be inferred from the file extension. Available formats are \"slp\", \"nwb\", \"labelstudio\", and \"jabs\".</p> <code>None</code> Source code in <code>sleap_io/model/labels.py</code> <pre><code>def save(self, filename: str, format: Optional[str] = None, **kwargs):\n    \"\"\"Save labels to file in specified format.\n\n    Args:\n        filename: Path to save labels to.\n        format: The format to save the labels in. If `None`, the format will be\n            inferred from the file extension. Available formats are \"slp\", \"nwb\",\n            \"labelstudio\", and \"jabs\".\n    \"\"\"\n    from sleap_io import save_file\n\n    save_file(self, filename, format=format, **kwargs)\n</code></pre>"}]}